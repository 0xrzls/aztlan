{"transpiled":true,"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"AztlanProfileRegistry","functions":[{"name":"block_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"address_to_block","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnRbts6DIbfJde9kERKIvsqwzB0XTYECNIiaw9wMPTdDymRdLMDG4WH3VSfafE3JdES4/46fDt+ff3x5XT5/vTzcP/p1+Hr9XQ+n358OT89Prycni5i/XVI+idDPtznO2nrbDFZ22Zb7bra/Wb9m113u9/9mg/3KC3h4b5qy7Nlu2YabUnF2jbbnKyd/Uqx6+LXU6eAXYPpoOmg6VTzq9IvJ4GmARaFatDdMmIGAQIHUc3qzuBgFtCAJzQDDXlCNShu0agnqDsJQDNANKjFoQuwQCsOzWCEOgAdyIC8M7mF3cImiKk4mCDm5IAO5o5FOhdU6AYknUtVqA5soPMzoU+o+qwJbsnZQd2bgM7PBLXI2Ksu27DUbNDYQIc8QMc1oU9oLthcsGk6DKjm3pq5NyoO5t6Tufds7r2Yewcw8Hh6tQi7x9O7PaJ7POSClMHBBGnMqoyUIDmQwYhQoXsfsj6s6zUgWx92HUZz5+p9XIfZ3dn65ORCOUFxwhQU/To6UfRzuZyzq+Ti/XLo5eoquUW/0CspBXm/Enrj9Z1Uo1/oFQoV9n4QelBcBcD7QeihPg1AKZeg7lTCVsIGYdOXdRKGDaNfhaB4hq4B6L433hUjduK4y26rCYPCpuljFLYS/TSDjPwZFXNQc9KZhDIIg9ipQVB30gQ0ak4UKmNEgzgHua2lFKS+dZwROagGsVOBoO4E4QHhoXlqtNhCZYxtEjnpBmoUsfRQ6eHRw4MiFgqb5hr0QapC45RDp5FNk7pT0eh5UHMaqzUJg8hp5NWk8KihUsPWQkUzDJOSrtYg0qgwDxJl1FUgfbcmaeYYsZPub0YSPWruks4fjjNb58+oOen8GaETRT+Ou5oROE74lIPISTPbiJ1GfJPCNuJro17IQc1J19yInVp4aD5P6uGrWYx9UA1iJz3FjPok2a5yUHXKKWixsVOBoFDRfEYa1J305DdiJy2rJulKG5FTt3kWak6UgtyWNSeRlXT+ahrUnXQmjZqT7hGaOWUUdkbs1DAobD1sPWwUNgobhx67TSYhqDvpHmFUg8Jj5AYP0kJv2Eb0g0aRlwZVpxY2jd5IfbXSKx2CwqZZXGFQd9IdzsiVIeUgcsoQxE4Fg8IW6wGxHhDrARjPqMP37e3u4DX6l5fr8agl+ruiXUr554fr8fJyuL+8ns93h38ezq+j08/nh8toXx6uclc0j5dv0org99P5qPR2t3inddfeqZs3yTkeAlItfFSCW2KTYNnjQ6LeBlHWFZD0KBsKSFhCofGNAqwrkBxqPoxKfU1hcxS6hdgoGq2N4qMKlNcU2rpCzrotDgVZi2U15aC5kegb61nJp1JOk7o2EbShAASuIIXTmgJvDQN6i3Fg4jWNzXH0ZRwlrSnkvC6xpESlJQRA2LegsCclpGpwhY51TSHjxmSmBjGXeQlCSqePa8gZ7hrlXRj/09jITakpfZuRcvCdRuq3GhuL2tg3ip7bahQfnc/a/nRFKK1uVhsSktHZZxPf7Xe/v6VlIzcpgaeW/JyktfQuG5tmJ4jZlMJsVQI29xtaNpxa2o5986P5mf48PcvH0lM+AeBqepatPaf5usqpuLqsWwOpvqhSHC47Tqm3IWxsnZ3jBOhSr4aGfKq6PQo3opDPSH6YwjIR5TbBYSM5tUbzcUglsyqxkZwV/S2rSHsEWoTQNiLYGgRkz0up0NouiY4+k/LxcH0q21+VkN+qfhJKTVB2Sci3K5eg3HZJMMRrLj/R1iQ2N4qYCvnsxHsU5LPHUh6VXQoUhUlJu2LA8m7z3xVDxRhF7XmXAsdatAx7FGBZTfkyvUuhxZ4NtGcUUp5GgYc7/DnOHe578pGL7zCMu55PHv/NRr0n/t/8P8vVw+PpevMPnDdVup4evp6Pdvn99fL47u7Lv89+x/8B9Hx9ejx+e70eVWn5L5D8+YTydPmt9Vm//MqlvBac9SLrPSkKkPrnNw3lPw==","brillig_names":["block_address"]},{"name":"burn_profile","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8904759240416909843":{"error_kind":"string","string":"Already burned"},"11807246117437261849":{"error_kind":"string","string":"Burn disabled"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["burn_profile"]},{"name":"change_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9981700386366515877":{"error_kind":"string","string":"Invalid admin address"},"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAACVHgIAAgEnAgMAEi8KAAMABAoqAgQFJAIABQAAAG0lAAAAvicCAgAACioBAgQnAgIBAAoqBAIFJAIABQAAAI4lAAAA0DAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAAAvSoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF1VRAoU/8A4w8BAIBJioBAAEFioYfnbfBaqU8BAIBJg==","debug_symbols":"nZTNjoMgEMffhbMHhm98lU3TWEsbE6OG6iabxnffwYjUAyS7F2YG5Mf8x8m8yd3dlue1Gx7ji9Rfb3LzXd93z2s/ts3cjQPuvgkNi5ak5hUxGBg0cjMWSG3RqM0AFbu1pAZAB0R0wg5Fh4noxB2ud0cwdNS6ViS+fp29c+Hxj3QwyanxbphJPSx9X5Hvpl+2j15TM2x2bjyeItINd7QIfHS9C95apds0fxW4ALFfR5+zAyHPDMgzhOERIYxIBGVPBJYnGKnZTjDS6ByhrENB0qFtTocoMEDIiACdigmanRAyj9DSxFJoRWVOiCoQuOGRIFi2mLokg2t16BDU/q+c8qOcBnLlLDIk8IMhhcq2VgFiZZRibUqC6b9kYZMSBTSbRaE/sYoHQzCd7YygN9vjlEcphkqT+ylQaFBtuI29YSzNImSxx01qcsnUCXLBqGk7fxqKa6D5rrn1bg8fy9B+nM4/UzyJQ3XyY+vui3eBlCYr4PrFTMX5JUxKDHBycHVZw9O/","brillig_names":["change_admin"]},{"name":"complete_recovery","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"lost_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"new_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2511765822595398882":{"error_kind":"string","string":"Recovery not initiated"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10309085656173016384":{"error_kind":"string","string":"Not recovery address"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["complete_recovery"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAAMELQgBAQAAAQIBJwICAQAtDgIBLQgBAwAAAQIBJwIEAAAtDgQDLQgBBQAAAQIBJwIGAAItDgYFJwIGABQnAgcECC0IAAgtCgEJLQoDCi0KBQstCgYMLQoEDQAIAAcAJQAAAy0tAgAAJwIGABUnAgcECC0IAAgtCgEJLQoDCi0KBQstCgYMLQoEDQAIAAcAJQAAAy0tAgAAJwIGABYnAgcAAScCCAQJLQgACS0KAQotCgMLLQoFDC0KBg0tCgcOAAgACAAlAAADLS0CAAAnAgYAFycCBwAeJwIIBAktCAAJLQoBCi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAMtLQIAACcCBgAYKQIABwAAA/SAJwIIBAktCAAJLQoBCi0KAwstCgUMLQoGDS0KBw4ACAAIACUAAAMtLQIAACcCBgAZJwIHBAgtCAAILQoBCS0KAwotCgULLQoGDC0KAg0ACAAHACUAAAM5LQIAACcCBgAaJwIHAQEnAggECS0IAAktCgEKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAzktAgAAJwIGABMnAgcECC0IAAgtCgEJLQoDCi0KBQstCgYMLQoCDQAIAAcAJQAAAzktAgAAJwICAA4nAgYEBy0IAActCgEILQoDCS0KBQotCgILLQoEDAAIAAYAJQAAA0otAgAAJwICAA8nAgYEBy0IAActCgEILQoDCS0KBQotCgILLQoEDAAIAAYAJQAAA0otAgAAJwICABAnAgYEBy0IAActCgEILQoDCS0KBQotCgILLQoEDAAIAAYAJQAAA0otAgAAJwICABEnAgYEBy0IAActCgEILQoDCS0KBQotCgILLQoEDAAIAAYAJQAAA0otAgAAJwICABInAgYEBy0IAActCgEILQoDCS0KBQotCgILLQoEDAAIAAYAJQAAA0otAgAAJigAgAQEeAANAAAAgASAAyQAgAMAAAMsKgEAAQX3ofOvpa3UyjwEAgEmJQAAAwQwCgAFAAQmJQAAAwQcCgUGADAKAAYABCYlAAADBDAKAAUABCY=","debug_symbols":"nZbdTiMxDIXfZa57EefPDq+CECplQJVGbTW0K61Q333j5HgoKxWh4YLv2HUO8TQx8zm8ji+X9+f94e34MTw8fg4v836a9u/P03G3Pe+Ph5r9HJz+ymV4oM3AoUMapEfCDYU6cgM5AhPYHYgiiNhXE6+UzoA4cGckMIGlM6EuoS57EDHXdUGZOwWxJLB0lgByo3cE9jpPDrS4rouVPoKIA+IgndGDuTM5EHUJdTmAiLmuS0ruFMSCWB9zYwJLY3AB7HWBCMydHrGv63JlcGDpjBGUzuTB3JlRn1GXUadHohGx7peV3FkQ67mojM6BEZRO8iDqdL+NiHW/okydEXG0uHTquWjkzkwg6jLqOIKI9TAXpXQWxHouKpOei8YElk4KIOq8BxEHvQdORYaIltGtd1EgdPNdMES24mzF7EwsGV1e71KSaMIy2kUX3EVu97KJZALFmYIJgfCW0W6oXqscvAnLtHaaSCYKRGunCSvOVpwzBFumtVNvWBZnYskUiNZOE9wFt3aaSCZQzG3SNGGZ1k5UIRDBMq0dFa2dJpKJApGsOFmxDp0ukJH26ERnY+3COxUJmag1cr1uBpuvz+d5HHW83gzcOoZP23k8nIeHw2WaNsOf7XRpRR+n7aHxvJ3rp9V7PLxWVsO3/TSqum6+Vrv7S5mFsVqIeDEgF39r4SUTLLxIWSzSrzfhi/PmUAKvckhuceB1eyi2hzpA3QqH4GJcHNivcSCyLgJFXuWQlz1QWdWFd9kc/KrvItQfcwhMaxyiWxxikFUOvDzJOp/XONThvDhwXuOQnZhDnZorHCg62wPFGweqp+vWgtJ9D3HBvk9x6etZ5vLdIv8wIyQUWLDcHKr/LfiHTihKslYo+XzX5MdWOCytSLhrUe5bRLHrUf+bLwb1kF2vTzXc7vbzt1feq1rN++3LNCJ8uxx2N5+e/57sE3tlPs3H3fh6mUd1+npv1rfHR6odEMvTVf/ePw==","brillig_names":["constructor"]},{"name":"create_profile","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"},{"name":"token_uri_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6759731346603734577":{"error_kind":"string","string":"Profile exists"},"13148562923741897405":{"error_kind":"string","string":"Profile creation paused"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15090718400027906422":{"error_kind":"string","string":"Profile was burned"},"15865011268275408360":{"error_kind":"string","string":"Username taken"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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jQsiAAWATAAGJAIABgAADN0jAAAKogsiAAWATQAGJAIABgAADLMjAAAKtwsiAAWATgAGJAIABgAADIkjAAAKzAsiAAWATwAGJAIABgAADF8jAAAK4QsiAAWAUAAGJAIABgAADDUjAAAK9gsiAAWAUQAGJAIABgAADAsjAAALCwsiAAWAUgAGJAIABgAAC+EjAAALIAsiAAWAUwAGJAIABgAAC7cjAAALNQsiAAWAVAAGJAIABgAAC40jAAALSgsiAAWAVQAGJAIABgAAC2MnAgwEADwGDAELIgALgEQABSQCAAUAAAt4JQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAuiJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAvMJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAv2JQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAwgJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAxKJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAx0JQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAyeJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAzIJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAAzyJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAA0cJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAA1GJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYULIgALgEQABSQCAAUAAA1wJQAAGawtCgEHLQoCCC0KAwktCgQKIwAADYUtCgoELQoHAS0KCAItCgkDJioBAAEFXc9j2FtjdjE8BAIBJioBAAEF0W0AbkcdUXY8BAIBJiUAAAhwLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDS4MgEYADQAiDQINLgyARgANACINAg0uDIBGAA0tCAEMJwINBAUACAENAScDDAQBACIMAg0t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","debug_symbols":"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","brillig_names":["create_profile"]},{"name":"emergency_set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"17057512740490565102":{"error_kind":"string","string":"Admin already set"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAACEJwICABIvCgACAAMnAgQAAAoqAwQFJAIABQAAAG0lAAAArTAKAAEAAicCAQABJwICABMwCgABAAImKACABAR4AA0AAACABIADJACAAwAAAKwqAQABBfeh86+lrdTKPAQCASYqAQABBey4dXaAo9XuPAQCASY=","debug_symbols":"pZTNjoMgEMffhTOHGb7xVTZNY1vamBA1VDfZNL77QitaD3hoLw4Dzm+Y/5B5kIs7jbdj0167O6l+HuQUGu+b29F353poujbuPgikj5akkpQYeBlFKkWJxZd5eQhitpZUiHGBMQjTDoO8eO5MEyU5xXEIzqUMbznjTfo6uHYgVTt6T8lv7cfnT/e+bp92qEM8BUpce4k2Aq+Nd2k10TUayqFCMz1HCy3kApBbApYJiELOBES9XgE12yBYGaGlETNCK1gvoeyGwHcI3PBMEIyVCGKvDK7VUocAW2LsiqlyHcIAlsTcIxjBFoIqEvROHQIwlyGYLrbDlBEGeFbCgDQlIexOOwy3uR3GQomAsPuszPquJFOf9MOYRU2LvPi42fdyIv9aTxTfCyo/FfQQvfrchM3MmxItNPXJu9m9ju357XT46/NJnpl96M7uMgaXSOvgxPj9YZJyOKSJGB2OlPPDlFL/Aw==","brillig_names":["emergency_set_admin"]},{"name":"get_address_by_username","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAAB/CcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAEnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAiUtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIlLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1MtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAARmLwoAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAIkKgEAAQX3ofOvpa3UyjwEAgEmJQAAAfwtCwQGCyIABoBEAAckAgAHAAACRycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALfIwAAAmAtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKKJQAABHguAgAHgAMoAIAEBAAEJQAABIouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAACyiUAAAUYLQ4KAS0OCAItDgUDLQ4JBCMAAANSJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1MtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASKLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADUiYlAAAB/C4IgEUABSMAAANjDSIABYBDAAYkAgAGAAAD0yMAAAN4LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPpIwAABFUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABFUBIgAFgEYABi0KBgUjAAADYyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABKUjAAAEsC4AgAOABSMAAAUXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNIoAYAFBAABAwCABgACgAYjAAAFFyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZfdaiM9DIbvZY5zYEmWf3orSylpmy6BkJZs88FHyb2vZEueZmEGdmBP+j72WO/YsjxOv6bXw/P159Px/Pb+a3r48TU9X46n0/Hn0+n9Zf95fD9L79cU9A+EOj3k3QQQTUtXJFNrk7XJ2hFNU1cGU+6agqn4FtHCprVrtf7a2xiiqbWBTHNXRNPUlcC0+2IMpuKTVEtXJtPcNYFp6pqDqcXl2lXn29TatT+nIOOrKncFa2v+mpauOt+mqSvZOLJxVLtGa0eL0/k2zV11vk3tfcniso3LNq7Y+4q1q8QBKEgg4G6KgQwAHJIByuSAFNihGui+d8gGERx8MHs4jx4PTxoeBTI46BipjFiCQzGoqQMHGYwyMWbJDpKCjEEJZ923BrphHapBIQeZKvJuSkGjZNcSoEMy0CV3iAbkY3SlDXSBDXSBmBWSga6rQzFo82lQDYr36AJRijPpAhVyW2CDaqD108EGZ62gDh6ltY6yuVmLvUN0KAaMDskg+eDk4dl7sodnDy8eXiScgkBFh9qh6FFtoLXfgQ30q9HBclj0nHawZJboPUnGkJRo0fyQbHdp72qQOlRNVAfulVD1pR2iQzVA70HvIe8h74new+7Do6cYJHRIBtkHZx+su6yTr1p1JD0Q2lw7cZ81hJaiTnNfdWrpio2KE40+rUNiJf3YGiUnHs6cnLQqjYqTzthovLeMvjLGee6F3A9CGNRib7fd5HfI0+flcNAr5NulIlfNx/5yOH9OD+fr6bSb/tufrm3Qr4/9uenn/iJPpUQO51dRMXw7ng5Kt90cHZZD5QbKHg5Uw2zB9x6w4iGZcgsAGg6Q6M4CVyw4mQMGHAaEfGdAywa5RjYHOVrzHLCUO4u4bEEjEZHibHCfBl6ORwSfAiLRkkNaduCYzYBj2RCfxgTS8vvXVkDgG4ly1W5xkI+pO2RezCKEf2oBcll4QeZv9fQ3Frn6XkCBtMmi0jgWNS5brDhAKe6AkRcPFqzsCHP1dKaCczrlA3bvsVJXOYGfrTzXJWTc+JXB5a9MWcvGOOIg27o4D6grK+FRGXKTzxlN9f5LtbKWTMW3NUfERYvVfaWcxlJiqEsmaykN45jIvVOXqmvNATjO+cRNDmUsA8OmOUT00oLvyfwLB45jFZxhk0Md5zQBbXGg+aQTb1oFpXHSqWxZhZTzKOy4Ib6OO7zmtCUe/XDKj8It8cXnf3d9b5n/H/GP0tq/HC93/6/f1Oly3D+fDtZ8u55fvj39/P/Dn/j/+x+X95fD6/VyUKf5n3758wPlVz5yeNQffNKUX6U7+VWkTdCnDPKUHm86md8=","brillig_names":["get_address_by_username"]},{"name":"get_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBABIvCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdJLDoMgEADQu7BmIfKtV2kag4oNCUFDoUljuHuh8VMWugHGmXlCYAGD6sKz1XacXqC5L6Bz2hj9bM3US68nm74uoMoDp6ChEIgU0Bgh2Cpa75TKBX8tCZqlU9aDxgZjIHhLE35Fr1na3+ylS9kKAmWHNCdw1EblVYRHd3XeiihjdG1Pa4F3gpYGujAQ2QnEj00gXhdEfU5wKshKcFbRnWC3QsAXAhZ4E0hdnwnk6hiYs/0cpLoVxiNFsteuuNOYNadlZ9QajsH2f1n/mbfM9iZmN/VqCE5l6XgYKI13JGCNHzH/7Qs=","brillig_names":["get_admin"]},{"name":"get_kyc_verifier_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBABEvCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdLRCoMgFADQf/HZh9RM16+MEVY2BLFwOhjhv09H1nyoF/V27z0puoJR9v7ZKTPNL9DeV9BbpbV6dnoehFOziV9XUKWBUdBSCHgMaAgQ5IrOWSlTwV9LhBZhpXGgNV5rCN5C+1/RaxHmNzthY7aCQJoxzhGclJZpFeDRXZ23Ikoo3trjmjc7QUsDXRiopplA7NgEYrgg8DnBKK83gjUV3YnmVgjkQiCcZKHG+Eyor45BWLOfo65uhfGIkRiULe40JM0q0Wu5hZM3w1/WfZacyW9isfMgR29lko6HgeJ4Rxxi8gjpb18=","brillig_names":["get_kyc_verifier_contract"]},{"name":"get_privacy_settings_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBABAvCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdJNroMgEADgu7BmIX+iXqVpDCo2JAQNhZe8GO5eaETLQjfAODOfENjAJAf/6pWZlzfoHhsYrNJavXq9jMKpxcSvG6jSwBnoGARNDFgIEOSK3lkpU8FPS4RWYaVxoDNeawj+hPbfovcqzHd2wsZsBYE0U5wjOCst0yrAs7u6bkUM43Zvj+uaHwQrDXRjIMoygfi5CcRxQeBrgrOG7gSvK3YQdVsI5EYgDckCxfhKoHfHILw+zkGrtjCeMRKjssWdhqRZJQYt93D2ZvzJuv81Z/KbWO0yyslbmaTzYaA4PlADMXmG9LcP","brillig_names":["get_privacy_settings_contract"]},{"name":"get_profile_id","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAAB/CcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAInAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAiUtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIlLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1MtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAARmLwoAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAIkKgEAAQX3ofOvpa3UyjwEAgEmJQAAAfwtCwQGCyIABoBEAAckAgAHAAACRycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALfIwAAAmAtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKKJQAABHguAgAHgAMoAIAEBAAEJQAABIouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAACyiUAAAUYLQ4KAS0OCAItDgUDLQ4JBCMAAANSJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1MtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASKLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADUiYlAAAB/C4IgEUABSMAAANjDSIABYBDAAYkAgAGAAAD0yMAAAN4LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPpIwAABFUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABFUBIgAFgEYABi0KBgUjAAADYyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABKUjAAAEsC4AgAOABSMAAAUXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNIoAYAFBAABAwCABgACgAYjAAAFFyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZfdaiM9DIbvZY5zYEmWf3orSylpmy6BkJZs88FHyb2vZEueZmEGdmBP8j72WO/Ysjwz+ZpeD8/Xn0/H89v7r+nhx9f0fDmeTsefT6f3l/3n8f0svV9T0B8IdXrIuwkgmpauSKbWJmuTtSOapq4Mptw1BVPxLaKFTWvXav21tzFEU2sDmeauiKapK4Fp98UYTMUnqZauTKa5awLT1DUHU4vLtavOt6m1a79OQcZXVe4K1tb8NS1ddb5NU1eycWTjqHaN1o4Wp/NtmrvqfJva/ZLFZRuXbVyx+xVrV4kDUJBAwN0UAxkAOCQDlMkBKbBDNdB975ANIjj4YPZwHj0enjQ8CmRw0DFSGbEEh2JQUwcOMhhlYsySHSQFGYMSzrpvDXTDOlSDQg4yVeTdlIJGya4lQIdkoEvuEA3Ix+hKG+gCG+gCMSskA11Xh2LQ5tOgGhTv0QWiFGfSBSrktsAG1UDrp4MNzlpBHTxKax1lc7MWe4foUAwYHZJB8sHJw7P3ZA/PHl48vEg4BYGKDrVD0aPaQGu/AxvoU6OD5bDoOe1gySzRe5KMISnRovkh2e7S7tUgdaiaqA7cK6HqTTtEh2qA3oPeQ95D3hO9h92HR08xSOiQDLIPzj5Yd1knX7XqSHogtLl24j5rCC1Fnea+6tTSFRsVJxp9WofESvqwNUpOPJw5OWlVGhUnnbHRuG8ZfWWM89wLuR+EMKjF3m67yd8hT5+Xw0FfId9eKvKq+dhfDufP6eF8PZ1203/707UN+vWxPzf93F/kqpTI4fwqKoZvx9NB6babo8NyKMijDy1cmNOw4HsPWPGQTLkFAA0HSHRngSsWnMwBAw4DQr4zoGWDXCObgxyteQ5Yyp1FXLag7HmMFGeD+zTwcjwi+BQQiZYc0rIDx2wGHMuG+DQmkJbvv7YCAt9IlFftFgd5mLpD5sUsQvinFiAvCy/I/K2e/sYiV98LKJA2WVQax6LGZYsVByjFHTDy4sGClR1hrp7OVHBOpzzA7j1W6ion8LOV57qEjBufMikvPmXKWjbGEQfZ1sV5QF1ZCY/KkDf5nNFU759UK2vJVHxbc0RctFjdV8nBWEoMdclkLaVhHBN579Sl6lpzAI5zPnGTQxnLwLBpDhG9tOB7Mv/CgeNYBWfY5FDHOU1AWxxoPunEm1ZBaZx0KltWIeU8CjtuiK/jHV5z2hKPfjjlo3BLfPH5372+t8z/j/hHae1fjpe7/+s3dboc98+ngzXfrueXb1c////wK/5//+Py/nJ4vV4O6jT/6ZefHyhf+cjhUT/4pClfpTv5KtIm6FUGuUqPN53Mbw==","brillig_names":["get_profile_id"]},{"name":"get_profile_visibility","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAAB/CcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAUnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAiUtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIlLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1MtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAARmLwoAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAIkKgEAAQX3ofOvpa3UyjwEAgEmJQAAAfwtCwQGCyIABoBEAAckAgAHAAACRycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALfIwAAAmAtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKKJQAABHguAgAHgAMoAIAEBAAEJQAABIouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAACyiUAAAUYLQ4KAS0OCAItDgUDLQ4JBCMAAANSJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1MtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASKLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADUiYlAAAB/C4IgEUABSMAAANjDSIABYBDAAYkAgAGAAAD0yMAAAN4LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPpIwAABFUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABFUBIgAFgEYABi0KBgUjAAADYyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABKUjAAAEsC4AgAOABSMAAAUXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNIoAYAFBAABAwCABgACgAYjAAAFFyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZffais5DMbfZa5zYUmW//RVDqWkbXoIhLTkJAtLybuvZEueZmEGdmBv8v3ssb6RbXlm8j29H15vv1+O54/PP9PTr+/p9XI8nY6/X06fb/vr8fMsvd9T0B8IdXrKuwkgmpauSKbWJmuTtSOapq4Mptw1BVPxLaKFTWvXav21tzFEU2sDmeauiKapK4Fp98UYTMUnqZauTKa5awLT1DUHU4vLtavm29TatV+nIOOrKncFa+v6NS1dNd+mqSvZOLJxVLtGa0eL03yb5q6ab1O7X7K4bOOyjSt2v2LtKnEAChIIuJtiIAMAh2SAkhyQAjtUA933DtkggoMPZg/n0ePhScOjQAYHHSOVEUtwKAY1deAgg1ESY5bVQVKQMSjhrPvWQDesQzUo5CCpIu+mFDRKdi0BOiQDnXKHaEA+RmfaQCfYQCeIWSEZ6Lw6FIOWT4NqULxHJ4hSnEknqJDbBBtUA62fDjY4awV18CitdZTNzVrsHaJDMWB0SAbJBycPz96TPTx7ePHwIuEUBCo61A5Fj2oDrf0ObKBPjQ62hkXPaQdbzBK9J8kYkhItuj4k213avRqkDlUXqgP3Sqh60w7RoRqg96D3kPeQ90TvYffh0VMMEjokg+yDsw/WXdbkq1YdSQ+Elmsn7llDaEvUae6rTm25YqPiRKNP65BYSR+2RsmJhzMnJ61Ko+KkGRuN+5bRV8Y4X3sh94MQBrXY+303+Tvk5Xo5HPQV8uOlIq+ar/3lcL5OT+fb6bSb/tqfbm3Qn6/9uel1f5GrUiKH87uoGH4cTwel+26ODsuhEOVZaOHCNQ4LfvSAFQ9ZKbcAoOEAiR4scMWCkzlgwGFAyA8GtGyQa/RpyNGac8BSHizisgVlX8dI8zLg4zLwcjwieAqIREsOadmBYzYDjmVDfBoJpOX7r82AwDcS5VW7xUEepu6QeXEVIfyvFiAvCy/I/KOe/otFrr4XUCBtsqg0jkWNyxYrDlCKO2DkxYMFKzvCXH05U8F5OeUB9uixUlc5gZ+tPNclZNz2lImBF58yZW01xhEH2dbFPKCuzIRHZcibfE4j1ccn1cpcMhXf1hwRFy1W95VyGlOJoS6ZrC1pGMdE3jt1qbrWHIDjvJ64yaGMaWDYlENEGHWBm3LgOGbBGTY51HFOE9AWB5pPOvGmWVAaJ53KlllIOY/Cjhvi63iH15y2xKMfTvko3BJfPP+H1/eW/P8V/yyt/dvx8vB//a5Ol+P+9XSw5sft/Pbj6vXvL7/i//e/Lp9vh/fb5aBO859++fmF8pWPHJ71g0+a8lW6k68ibYJeZZCr9HzXZP4B","brillig_names":["get_profile_visibility"]},{"name":"get_quest_points_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBAA8vCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdLLroMgEADQf2HNgqdYf6VpDCo2JAQNhZvcGP690EgtC90A48wcw2MDkxrCs9d2Xl6gu29gcNoY/ezNMkqvF5u+bgDlQXDQcQjaFPAYISgVvXdK5YKflgSt0inrQWeDMRD8SRM+Ra9V2s/spUtZBIGyU5oTOGuj8irCoxudt2KOUbO3pzU7CF4b+MLAjBcCi0PAglQEOScEb9lOiAbxL9HcKoFeCLSlRWCEnAnsahtUfI8incStMh4pkqN21Z3GrDktB6P2cA52/Mn6/7VkyptY3TKqKTiVpeNh4DTecQsJfcT8tzc=","brillig_names":["get_quest_points_contract"]},{"name":"get_recovery_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAAB/CcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAwnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAiUtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIlLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1MtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAARmLwoAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAIkKgEAAQX3ofOvpa3UyjwEAgEmJQAAAfwtCwQGCyIABoBEAAckAgAHAAACRycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALfIwAAAmAtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKKJQAABHguAgAHgAMoAIAEBAAEJQAABIouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAACyiUAAAUYLQ4KAS0OCAItDgUDLQ4JBCMAAANSJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1MtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASKLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADUiYlAAAB/C4IgEUABSMAAANjDSIABYBDAAYkAgAGAAAD0yMAAAN4LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPpIwAABFUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABFUBIgAFgEYABi0KBgUjAAADYyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABKUjAAAEsC4AgAOABSMAAAUXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNIoAYAFBAABAwCABgACgAYjAAAFFyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZffais5DMbfZa5zYUmW//RVDqWkbXoIhLTkJAtLybuvZEueZmEGdmBv+v3ssb6RbXmcfk/vh9fb75fj+ePzz/T063t6vRxPp+Pvl9Pn2/56/DxL7/cU9A+EOj3l3QQQTUtXJFNrk7XJ2hFNU1cGU+6agqn4FtHCprVrtf7a2xiiqbWBTHNXRNPUlcC0+2IMpuKTVEtXJtPcNYFp6pqDqcXl2lXzbWrt2p9TkPFVlbuCtXX9mpaumm/T1JVsHNk4ql2jtaPFab5Nc1fNt6m9L1lctnHZxhV7X7F2lTgABQkE3E0xkAGAQzJASQ5IgR2qge57h2wQwcEHs4fz6PHwpOFRIIODjpHKiCU4FIOaOnCQwSiJMcvqICnIGJRw1n1roBvWoRoUcpBUkXdTCholu5YAHZKBTrlDNCAfozNtoBNsoBPErJAMdF4dikHLp0E1KN6jE0QpzqQTVMhtgg2qgdZPBxuctYI6eJTWOsrmZi32DtGhGDA6JIPkg5OHZ+/JHp49vHh4kXAKAhUdaoeiR7WB1n4HNtCvRgdbw6LntIMtZonek2QMSYkWXR+S7S7tXQ1Sh6oL1YF7JVR9aYfoUA3Qe9B7yHvIe6L3sPvw6CkGCR2SQfbB2QfrLmvyVauOpAdCy7UT96whtCXqNPdVp7ZcsVFxotGndUispB9bo+TEw5mTk1alUXHSjI3Ge8voK2Ocr72Q+0EIg1rs/b6b/A55uV4OB71CflwqctV87S+H83V6Ot9Op9301/50a4P+fO3PTa/7izyVEjmc30XF8ON4Oijdd3N0WA6VG6eChYN8Vsqw4EcPWPGQlXILABoOkOjBAlcsOJkDBhwGhPxgQMsGuUY2Bzlacw5YyoNFXLag7OsYKc4Gj8vAy/GI4CkgEi05pGUHjtkMOJYN8WkkkJbfvzYDAt9IlKt2i4N8TN0h8+IqQvhfLUAuCy/I/KOe/otFrr4XUCBtsqg0jkWNyxYrDlCKO2DkxYMFKzvCXH05U8F5OeUD9uixUlc5+SdCrrbZIePGrwzWxa9MWVuNccRBtnUxD6grM+FRGXKTzyua6uOXamUumYpva46Iixar+0o5janEUJdM1pY0jGMi905dqq41B+A4ryducihjGhg25RBxrgvclAPHMQvOsMmhjnOagLY40HzSiTfNgtI46VS2zELKeRR23BBfxx1ec9oSj3445Ufhlvji+T9c31vy/1f8s7T2b8fLw//rd3W6HPevp4M1P27ntx9Pr39/+RP/f//r8vl2eL9dDuo0/9Mvf36h/MpHDs/6g0+a8qt0J7+KtAn6lEGe0vNdk/kH","brillig_names":["get_recovery_address"]},{"name":"get_social_verifier_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBAA4vCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fZLBDoMgDIbfhTMHQBD1VZbFoOJCQtAwWLIY3n2wDB0HvbSU9v9oQzcwycE/emXm5Qm62wYGq7RWj14vo3BqMfF2AygZzkDHIGhiwEKAIFf0zkqZCv4kEbQKK40DnfFaQ/AS2n+LnqswX++EjVkEgTRT9BE4Ky3TKcBDjc6lmLYN/ckxQwTvCFYy8AUDU5YRmB9NYE4KBDlHcLZ3wWvEdkTdFoTqglA1VSZQQs4I9GqMitf7HBS1BeMeIzEqW/xpSDSrxKDlL5y9Gf+y7r3mTN6J1S6jnLyViXQsBo72hhtIqntIr30A","brillig_names":["get_social_verifier_contract"]},{"name":"get_token_uri","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAAB/CcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAMnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAiUtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIlLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1MtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAARmLwoAAwABJigAgAQEeAANAAAAgASAAyQAgAMAAAIkKgEAAQX3ofOvpa3UyjwEAgEmJQAAAfwtCwQGCyIABoBEAAckAgAHAAACRycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALfIwAAAmAtCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKKJQAABHguAgAHgAMoAIAEBAAEJQAABIouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAACyiUAAAUYLQ4KAS0OCAItDgUDLQ4JBCMAAANSJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1MtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASKLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADUiYlAAAB/C4IgEUABSMAAANjDSIABYBDAAYkAgAGAAAD0yMAAAN4LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPpIwAABFUtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASKLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABFUBIgAFgEYABi0KBgUjAAADYyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABKUjAAAEsC4AgAOABSMAAAUXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNIoAYAFBAABAwCABgACgAYjAAAFFyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZffais5DMbfZa5zYUmW//RVDqWkbXoIhLTkJAtLybuvZEtOZ2EGdmBv8v3ssb6RbXlm8j29H15vv1+O54/PP9PTr+/p9XI8nY6/X06fb/vr8fMsvd9T0B8IdXrKuwkgmpauSKbWJmuTtSOapq4Mptw1BVPxLaKFTWvXav21tzFEU2sDmeauiKapK4Fp98UYTMUnqZauTKa5awLT1DUHU4vLtavm29TatV+nIOOrKncFa+v6NS1dNd+mqSvZOLJxVLtGa0eL03yb5q6ab1O7X7K4bOOyjSt2v2LtKnEAChIIuJtiIAMAh2SAkhyQAjtUA933DtkggoMPZg/n0ePhScOjQAYHHSOVEUtwKAY1deAgg1ESY5bVQVKQMSjhrPvWQDesQzUo5CCpIu+mFDRKdi0BOiQDnXKHaEA+RmfaQCfYQCeIWSEZ6Lw6FIOWT4NqULxHJ4hSnEknqJDbBBtUA62fDjY4awV18CitdZTNzVrsHaJDMWB0SAbJBycPz96TPTx7ePHwIuEUBCo61A5Fj2oDrf0ObKBPjQ62hkXPaQdbzBK9J8kYkhItuj4k213avRqkDlUXqgP3Sqh60w7RoRqg96D3kPeQ90TvYffh0VMMEjokg+yDsw/WXdbkq1YdSQ+Elmsn7llDaEvU6dFXndpyxUbFiUaf1iGxkj5sjZITD2dOTlqVRsVJMzYa9y2jr4xxvvZC7gchDGqx9/tu8nfIy/VyOOgr5MdLRV41X/vL4Xydns6302k3/bU/3dqgP1/7c9Pr/iJXpUQO53dRMfw4ng5K990jOiyHQgwhWrgwxmHBcw9Y8ZCVcgsAGg6QaGaBKxaczAEDDgNCnhnQskGukc1BjtYjByxlZhGXLSj7OkZ6LAPOl4GX4xHBU0AkWnJIyw4csxlwLBvi00ggLd9/bQYEvpEor9otDvIwdYfMi6sI4X+1AHlZeEHmH/X0Xyxy9b2AAmmTRaVxLGpctlhxgFLcASMvHixY2RHm6suZyo/jLQ+wucdKXeUEfrbyoy4h48anDPHiU6asrcY44iDbupgH1JWZ8KgMeZM/0kh1/qRamUum4tuaI+Kixeq+Uk5jKjHUJZO1JQ3jmMh7py5V15oDcHysJ25yKGMaGDblEBFGXeCmHDiOWXCGTQ51nNMEtMWBHiedeNMsKI2TTmXLLKScR2HHDfF1vMNrTlvi0Q+nfBRuiS+e/+z1vSX/f8U/S2v/drzM/q/f1ely3L+eDtb8uJ3ffly9/v3lV/z//tfl8+3wfrsc1Onxp19+fqF85SOHZ/3gk6Z8le7kq0iboFcZ5Co93zWZfwA=","brillig_names":["get_token_uri"]},{"name":"get_total_burned_profiles","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBABUvCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdJNroMgEADgu7BmIciPepWmMajYkBA0FF7yYrh7oREtC90A48x8QmADkxz8q1dmXt6ge2xgsEpr9er1MgqnFhO/bqBKA6egoxA0MaAhQJAremelTAU/LRFahZXGgc54rSH4E9p/i96rMN/ZCRuzFQTSTHGO4Ky0TKsAz+7quhVRyvDeHtctOwhaGujGQIRmAvFzE4jjgsDXBKcN2QnOKnoQrC2E+kaomzoLBOMrgdwdo+bsOAep2sJ4xkiMyhZ3GpJmlRi03MPZm/En6/7XnMlvYrXLKCdvZZLOh4Hi+EANxPUzpL99AA==","brillig_names":["get_total_burned_profiles"]},{"name":"get_total_profiles","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABbJwIBABQvCgABAAItCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACDKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdLRCoMgFADQf/HZh0xN16+MEVY2BLFwOhjhv09H1nyoF/V27z0puoJR9v7ZKTPNL9DeV9BbpbV6dnoehFOziV9XUKWBUdBSCHgMaAgQ5IrOWSlTwV9LhBZhpXGgNV5rCN5C+1/RaxHmNzthY7aCQJoxzhGclJZpFeDRXZ23Ikoo29rjmpOdoKWBLgxEaCYQOzaBWF0Q9TnBKCcbwZqK7kRzKwR8IWCOs0Dq+kwgV8fArNnPQapbYTxiJAZlizsNSbNK9Fpu4eTN8Jd1nyVn8ptY7DzI0VuZpONhoDjeEYc1foT0ty8=","brillig_names":["get_total_profiles"]},{"name":"has_profile","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACCycCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAcnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjQtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI0LQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2ItAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAAR1LwoAAwABHAoBAwEcCgMCABwKAgEBJigAgAQEeAANAAAAgASAAyQAgAMAAAIzKgEAAQX3ofOvpa3UyjwEAgEmJQAAAgstCwQGCyIABoBEAAckAgAHAAACVicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALuIwAAAm8tCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKZJQAABIcuAgAHgAMoAIAEBAAEJQAABJkuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAAC2SUAAAUnLQ4KAS0OCAItDgUDLQ4JBCMAAANhJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA2ItAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASZLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADYSYlAAACCy4IgEUABSMAAANyDSIABYBDAAYkAgAGAAAD4iMAAAOHLQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAP4IwAABGQtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASZLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABGQBIgAFgEYABi0KBgUjAAADcioBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABLQjAAAEvy4AgAOABSMAAAUmLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABRIuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABOEoAYAFBAABAwCABgACgAYjAAAFJiYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZjdbuM4DIXfxde5EEn9sa8yKIq0TQcBgrTINAssirz7khIpNwvYmDEwNz2fZPGYlijZzdf0eni+/nw6nt/ef00PP76m58vxdDr+fDq9v+w/j+9n6f2agv6BwNND2U0A0bR2RTK1NlmbrB3RNHdNYJq65mAqvlW0JlPuytbPvY0hmlobyLR0RTTNXQlMuy/GYCo+WbV2TWRaumYwzV1LMLW4wl0136bW5n6dgoxn1dQVrK3z17R21Xyb5q5k48jGEXeN1o4Wp/k2LV0136Z2v2xxxcYVG1ftftXaLHEAChIIuJtiIAMAh2yAkhyQQnJgA133DsUggoMPTh6eRo+HZw2PAgUcdIxURqzBoRpw7pCCDEZUkJuiRCVAB+/RicAkoDOBsjSpggMb6KJ1qB1yUB+5Rdb6xqpQDLSiOiQHNog+JqGBlncHHSwTnvUBO1SDSg5s0PJpYD1FF4WCgC5Kh2yA0YENyAfrWjSIHqVLQKCQHNhAl6BDMdBUO/jg6uF19Hg4ezhbeNXVIVQoBlr8HdhAC6mB1n2HahBtDqseHQ1ScPAerWaS+uE2P1GhGLSJapANtHq1Elhv2sFqg3W3dfCe6D3Re5L3JO/J7uM1xq3GGhSDVmwNfHD1wbrKLXmtOpIeCC3XRpqsZi2UnGj0ab5GGpuVIg0afVqHVBoVJz0pjIZzgUHVqdIgduJxX/Y+8KkXKk4++QJ+D2h1Gm+33eSvl6fPy+Ggb5dv7xt5C33sL4fz5/Rwvp5Ou+mf/enaBv362J+bfu4vclWq+XB+FRXDt+PpoHTbzdFhORTkaMsWLkx1WKR7D1jxCJncAoCGA2S6s8AVi+RJYMBhQJjuDGjZoHBM5lCY5xyw1juLuGxBxecxytoMg/tpSMvxiOApIBItOeRlhxSLGaRYN8TnkUBevv/aExD4QqK8hbc4lOiTiCUtziKEv2oBuUYvyPKtnv7EQs5ut6iQN1kwjW3BcdlixQFqdQeMaXFjwcqKpMQ+nbniPJ1yQt17rNRVyeB7q8x1CQU3njKRF0+ZujYbY4uDLOtiHsArT5JGZZQc5hnNfH9SrTxLoerLWiLiosXqulIZ0wEx8JLJ+qOU+VEwLOaxcmimgn7e1DkHivTb6xrGXtVX41KJrzlAivOi4iaHOuYSw6YcIsIoTtyUQ4rjKVKBTQ48DosMtMWB5uOG0qanoDyOG6pbnkL21CjJuCGex4cEl7wlHv2EkI/WLfHV87/7htiS///iH6W1fzle7n5PuKnT5bh/Ph2s+XY9v3y7+vnvh1/x3yM+Lu8vh9fr5aBO848S8ueHvLN38s/7o36TSlM2504+TrUJelU2Gqb8eNNk/gM=","brillig_names":["has_profile"]},{"name":"initialize_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"15691186487269729606":{"error_kind":"string","string":"Admin already initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAACyJwIBABMvCgABAAIcCgIEARwKBAMAHAoDAgEnAgMBAAoqAgMEJAIABAAAAHYlAAAA2ywCAAIAMDkIcb+hPKSdWL4XQd+3JFYtsktSypZ6HUp9Cwj6ztQnAgMAEjAKAAIAAycCAgABMAoAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAADaKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXZwkr5hh8lRjwEAgEm","debug_symbols":"rZTNbsMgDMffhXMOGAOGvspUVWlLq0hRWqXJpKnKuw8ySJoDSFt3iW0+fjH+W36yszuO10PTXW4Ptvt4smPftG1zPbS3Uz00t86vPhkPH23ZTlWM5GyMXyNv1GzsT2R9ZCoGnEcbY8BoDdsBekep6GieHO2dcIYgONNUsZTCYeidCxm85OQzvde96wa268a2rdhn3Y7zoce97mY71L3f5RVz3dlbD7w0rQveVK23ef4qEpl4Gw03C0BtCZAnAEgVCQC0pgAkNgiRR5AyMiJIc7UgtN0QsEBAg4kghcgRZOkZSHp5h+Q2xyi+g9Z3CJ4j6DxBkYgAZdYMUOIv9KRFT+A5PQsEyVXSU3KSOYItlFJySJWUgrIdAYUsDMekhuHK5EoJhcYkgzapYWxWDRDF3jZrcyuhc5BiPW1KQwJmFQH5DwVV7xdUv19Q+mtB9z6qT02/GcxToPVNfWxdDC9jd3rZHb7uaScN9nt/O7nz2LtAWqc7+O+HMBXiPgxqH6CsUO+n8Otv","brillig_names":["initialize_admin"]},{"name":"initiate_recovery","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"lost_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10309085656173016384":{"error_kind":"string","string":"Not recovery address"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHwoAAgADgEkuCIBJAAElAAAARSUAAABwKAIAAQSASicCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABJiUAAAGPHgIAAgEnAgMADCcCBQQGLQgABi0KAwctCgEIAAgABQAlAAABuC0CAAAtCgcECyIABIBGAAMLIgADgEQABSQCAAUAAAC/JQAAAzIvCgAEAAMKKgMCBCQCAAQAAADXJQAAA0QnAgIABycCBAQFLQgABS0KAgYtCgEHAAgABAAlAAABuC0CAAAtCgYDCyIAA4BGAAILIgACgEQABCQCAAQAAAEcJQAAAzIvCgADAAIcCgIEARwKBAMAHAoDAgEkAgACAAABPiUAAANWJwICAA0nAgQEBS0IAAUtCgIGLQoBBwAIAAQAJQAAAbgtAgAALQoGAwsiAAOARgABCyIAAYBEAAIkAgACAAABgyUAAAMyJwIBAAEwCgABAAMmKACABAR4AA0AAACABIADJACAAwAAAbcqAQABBfeh86+lrdTKPAQCASYlAAABjy0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUuDIBGAAUAIgUCBS4MgEYABQAiBQIFLgyARgAFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy4MgEYABwAiBwIHLgyARgAHACIHAgcuDIBGAAcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAADaC0CAAAnAgEEBy0IAActCgQILQoDCS0KBQotCgYLLQoCDAAIAAEAJQAAA2gtAgAALQsGAQsiAAGARAACJAIAAgAAAvYnAgcEADwGBwEnAgEEBy0IAActCgQILQoDCS0KBQotCgYLAAgAAQAlAAAEkS0CAAAtCwMBASIAAYBIAAMtCwMCLQoCASYqAQABBQLcbieAdhKdPAQCASYqAQABBY8ROsjPRHVAPAQCASYqAQABBTEEisAt600cPAQCASYlAAABjy0LBAYLIgAGgEQAByQCAAcAAAOKJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAABB0jAAADoy0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACiQCAAoAAAPIJQAABaQuAgAHgAMoAIAEBAAEJQAABbYuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaASAAFDioGBQckAgAHAAAECCUAAAZELQ4KAS0OCAItDgUDLQ4JBCMAAASQJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAABJEtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAAW2LgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEgAAy0OCAQjAAAEkCYlAAABjy4IgEUABSMAAAShDSIABYBDAAYkAgAGAAAFESMAAAS2LQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAUnIwAABZMtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAAW2LgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABZMBIgAFgEgABi0KBgUjAAAEoSoBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABdEjAAAF3C4AgAOABSMAAAZDLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABi8uAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABf4oAYAFBAABAwCABgACgAYjAAAGQyYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZnRTvM6DMffZddcJLETx7wKQmjA+DRpGmgfHOkI8e7HTmJ3Q2rF6cQN+c1N/nUcx2nL5+Z59/jx52F/fHn9u7m9+9w8nvaHw/7Pw+H1afu+fz2K9XMT9E+MtLmFm01MaXObtaXewvgNpbcYRouj5d7m8TvX3hYZV6WlMNra21p6y3FzG/WGLDeKeLNJIQ2IwSALFIEUDNzCAwAMaAAmA7PkaKDDWaDAAIoGPKDKRJLeneWmSUdx7gAhGKiFBCIYyPSSDIcEBmbRCHYoAzSGHfKAbBYNYwcZDkmglAGEA2oy0DXTu3PqgCqISYEHqGAHsxSzFLMQGJilWh8NQoehnINEDGXhsmZKhzIA7BKYBc2CZtGZdjBLsT6FBpApa9I0qGCgfaKA5k+H0qHo6nRAAx6gy9RhDC/N+QZ1AJgFrA/qKFSoA3IyKANKMEAD60zWmWhANUu14W0WDbIBd6AABmM4xWgwOlMKBm7R4ZKipPsCJSWoLUEDHtBSooG6KpuRdDt0oAG6LzpkAx5QrXO14WwWHsNrSxJW4AEahBwEqlzKUYEH6CgF1grQoQzQUpAl61hTK4NCNuABukwdaEC2PsUu6aJkiQ/rJmrQ3GhQBugm6kAdYgjJSXtpXQsRndioFctGrVx28hGtZHbysVk9K42qkZbMQcVIy+cgdPIR1VWq29hV2FRiCE6qQkottJ3IqBX/TtVIE6mTZtKgEeDYy3+jDE5uq9pPq31q8WOldt9O6MRGWj41TYSqUYtpJzJCt6Hbstuy24rbiuuR26gY1eCETj6CfUTLDZ0RaIoXtYF636l5z42qEbited9II1lio2KU3abpW1I7c4MTOrkyWfygJXMni3M7EwbZfTEkJ+uHvh7o64HR7oEts/nr62ZjzwwP76fdTh8Zzh4i5NHibXvaHd83t8ePw+Fm88/28NE6/X3bHlv7vj3JVYnS7vgsrQi+7A87pa+baXSYHyqVKI3RRDQJ5EuFOK+AFXAoyAGXXKHwhUKaV6hyNA2FKkfRnMLSLGrwWdTEc7PAeQWpDjAUZOuCK8QCP5aItZpEwjwrUeYlcmZbSznWcJIIdCFBC6HQbB/rWScBSqtiiXUulrwUCMwey7Oc+u5EXPIiV8sqKiHP5URcSEyCaktKmGYTM6almQAVnwoGvjY3y+wOW1Lg5BPhs8T6vkfz9em9qPHD/I50fYLH+psZfh7PgnPxTOH6FE/x6hRP6eoU1+leneLLU6FpKinMSixk13QG5Dr5AAjrVrWs2Gc1BEvOKo+cs3lRr99nixo/3GcQrt9nEH9xn13EM8/GE5ayE4M5oU9Ns14ALrkBZXKjziUn5KUaDuw1nGfzG8pixahTyZC3+xVHScw2EfmsM+2RlC+9WKqd7HWLmKf8lKfyS42F4x3IVhVhyqz07VFrYRopRXNC3kxgVmIhN7O+afdqcfaI8j8EirtQFjxYmgRE2+nyKlVWSRBaJJN8PpiVyL8qEYsfQ3KSpVUS8onCJGosqyQYvHAyzkosbY7goZAXd16jEDNOh3papVD9LE1hlQ+YzgreKh8y+iwyxVUK7GtRIqxRgGk1Ia+ahbyRu0JdMwsqwR9JcMV49pOcaU0+crIKw7jq/tX8vyjUa/z/Nv5efm2f9qeLf1h8qdJpv3087MbPl4/j09nV93/f7Ir9w+Pt9Pq0e/447VRp+q+H/LlL8mAKAe/1i5n8JLihqj/kk8qdfOiXa3T/pa78Bw==","brillig_names":["initiate_recovery"]},{"name":"is_admin_initialized","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABqJwIBABMvCgABAAIcCgIDARwKAwEAHAoBAgEtCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACSKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdLLroMgEADQf2HNApCnv9I0DSo2JAQN1ZvcGP690PqoC9wwjuMcmWQW0Jlmfj6s74cXqG8LaIJ1zj4fbmj1ZAef3i4A5UMwUDMIJPoGDmoBgcLfkLMYIdjaHlMwJnf9OEkfdTB+ArWfnYPgT7v589Fr1P4TJx1SFUFgfJdiAnvrTH6K8OhG5VbMpFRrO2YKq51gZwNfGJiyjcDiuAQW5ESQMiGYpCshOGI7wdVJqC6ESlabQAkpCfRqjErwfQ6KVMm4nEMccxBUEnhZYIKsAJPHDSpaxXhPqW5tOO1azFSwunFmTfvZtz/V6X/cKtuujmFoTTcHk6VjYXE6bwRDwu8x/+0N","brillig_names":["is_admin_initialized"]},{"name":"is_blocked","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"blocked_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBLJwAABAMnAgMEAicCBAQAHwoAAwAEgEguCIBIAAEuCIBJAAIlAAAAUSUAAAB1LgIAAYBKKAIAAgSASicCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcEAAEmJQAAARknAgMABicCBQQGLQgABi0KAwctCgEIAAgABQAlAAABQi0CAAAtCgcECyIABIBGAAELIgABgEQAAyQCAAMAAAC/JQAAArwnAgMEBS0IAAUtCgQGLQoCBwAIAAMAJQAAAUItAgAALQoGAQsiAAGARgACCyIAAoBEAAMkAgADAAAA/yUAAAK8LwoAAQACHAoCAwEcCgMBABwKAQIBLQoCASYoAIAEBHgADQAAAIAEgAMkAIADAAABQSoBAAEF96Hzr6Wt1Mo8BAIBJiUAAAEZLQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS4MgEYABQAiBQIFLgyARgAFACIFAgUuDIBGAAUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLgyARgAHACIHAgcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAALOLQIAACcCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgstCgIMAAgAAQAlAAACzi0CAAAtCwYBCyIAAYBEAAIkAgACAAACgCcCBwQAPAYHAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAP8LQIAAC0LAwEBIgABgEcAAy0LAwItCgIBJioBAAEFAtxuJ4B2Ep08BAIBJiUAAAEZLQsEBgsiAAaARAAHJAIABwAAAvAnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAADiCMAAAMJLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJwILAQEkAgAKAAADMyUAAAUPLgIAB4ADKACABAQABCUAAAUhLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEcABQ4qBgUHJAIABwAAA3MlAAAFry0OCgEtDggCLQ4FAy0OCQQjAAAD+ycCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAP8LQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAFIS4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBHAAMtDggEIwAAA/smJQAAARkuCIBFAAUjAAAEDA0iAAWAQwAGJAIABgAABHwjAAAEIS0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEkiMAAAT+LQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAFIS4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAAT+ASIABYBHAAYtCgYFIwAABAwqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAU8IwAABUcuAIADgAUjAAAFri4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAWaLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAVpKAGABQQAAQMAgAYAAoAGIwAABa4mKgEAAQVFp8pxGUHkFTwEAgEm","debug_symbols":"tZjdbuM4DIXfJde5kKj/vsqgKNI2HQQI0iKTLLAo8u5LUjxys4CNjgdzU36mxWOKomQ3n5vX/fP159Ph9Pb+a/Pw43PzfD4cj4efT8f3l93l8H5i7+fGyR9PtHmgLdvSbbDrkLuNzmw027pNdp1qt5njEtvizNZua+62+c1DEZvVknNmo9narQ9m7VryU8tx3jGEaBDJIDlAYuCHUeaHeYnK2aCYJ+g8OeEQPCAbRHgiPAkeUVbI8GSMKQSAcuUpUNhuosytQzXwuOXhIXgIHl0BBXgixmjxBRKUswMkgIzxDCUAqkElQDaQVemQABaeNHkB7wDDgzEkUZEhOEAEVANZpg7ZIGFwwuDUDDI8GeE6C4ViUD0AT68IbxjcbHB2BIDHS3gWkHBuiaxLIKAtoZANtPurQAI0gxQAxUB7QwGDC8LL8CBcm6Qx6BIwFEkjOAEWDFzeEpKBNECHapAIwKkG7roi9QncAEXq0yEBmoHUR6A6D8gGsrgdZDAXqsriKkhDdigGmo9CNUjwSDUC78EqRVCQInSoBjL3DhgsRehgUU3aL2SBZiB7p0MxIA9IAAwOCA/wRIRHhCeEy+4OvNxNVrBDNZD269AMajRoBLAaeieHmlEE+eGTrgpVSIvUhPSJnRJIC9Yp9pZgaqAaBlVQG74GHz9u0PD54fPQ8zR82ndKshGM0qAREUeELr/MyEs/RvVJ9kbR5uE1e6U6fJq9khQyeqViRI4GcdWivqFk5xqlQVAmQv1I+7UT6kyacyc8l9LwjfWgsR401oPyeIZ2cLvdthu8SZ8u5/1eXqRfXq38wv3Ynfeny+bhdD0et5t/dserDvr1sTupvezOfJertD+9smXBt8NxL3TbTtFuPtRHPnwtnDmFIZHuNfyChssBEry+Q8Hn8G0JXkZIUEyzEmFegg9/1CHxTpwkXLmTiPMSuTVTKD7P5vD9ahY/V83859XMf17N+q1q5kpxtpptXqJkj2qWOgkUWlnNNt+bi50VhwafKbN5eFqYSaoRU8luqmdu9xIL3Vn4aw4SkWhWIi7NJJQ8phJdmxVZnEqZpkJuVmKhu1Ih7LM65RDi93dJwjT4eJ4EKN2nsNCdpY1FLe1LX1Ct9xoL7RkKGjyGqb/pvrNoYRpEHkkQhTArsdCcKRaUMtY1AnmkkBcyWJpE8OhLft/lVRIlopJU0nwp01+V8HnsUd7mtEqiNCyHrz6vkmhhHN4tzkosbQ43SsEfXG2NAv9PPZ14tEqhjoOG3KocIvlxctOqHFIcs/j6Iv0dhTbWIvuwRiFMqxnSqlmEPN7Eoa6ZBb9wxnkdV8S38TXRypp+bOMV3OKq51fkf3dQr8n/f/GPfLV7OZzvfo26idL5sHs+7u3y7Xp6+XL38u8H7uDXrI/z+8v+9Xrei9L0kxb/+cFf9Fv+Wn+Uf4n4MtE2Fbnwcq+0LVX/eJNU/gM=","brillig_names":["is_blocked"]},{"name":"is_burn_enabled","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAABqJwIBABovCgABAAIcCgIDARwKAwEAHAoBAgEtCgIBJigAgAQEeAANAAAAgASAAyQAgAMAAACSKgEAAQX3ofOvpa3UyjwEAgEm","debug_symbols":"fdJNroMgEADgu7BmAciPepWmMajYkBA0VF/yYrh7oZVSF7hhQJyPmWR2MKp+e3TaTvMTtLcd9E4box+dmQe56tmGrztAcREMtAyCGn0CB62AoMGfEE/eQ5DSutUpFbN+nKAv0im7gtZuxkDwJ832/um5SPuOq3ThFkGg7BhiACdtVNx5mLNRORUzwVJ62Av2JdjZwBcGpiwRWOQisCAngpQJwWp6EIKjXARvTkJ1IVR1lQRKSEmgV21Ugn/7oKgpGZd9iNwHQSWBlwUmyAGwOldQ0cr7ezjKQbvTrPlIOS17o47jtNnh53b9X9JNmtXFzYMaN6eilAcWh/VGMCT87uNrLw==","brillig_names":["is_burn_enabled"]},{"name":"is_profile_burned","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACCycCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAQnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAjQtAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAI0LQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA2ItAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAIkAgACAAAB9SUAAAR1LwoAAwABHAoBAwEcCgMCABwKAgEBJigAgAQEeAANAAAAgASAAyQAgAMAAAIzKgEAAQX3ofOvpa3UyjwEAgEmJQAAAgstCwQGCyIABoBEAAckAgAHAAACVicCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALuIwAAAm8tCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKZJQAABIcuAgAHgAMoAIAEBAAEJQAABJkuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAAC2SUAAAUnLQ4KAS0OCAItDgUDLQ4JBCMAAANhJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA2ItAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASZLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADYSYlAAACCy4IgEUABSMAAANyDSIABYBDAAYkAgAGAAAD4iMAAAOHLQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAP4IwAABGQtCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASZLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABGQBIgAFgEYABi0KBgUjAAADcioBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABLQjAAAEvy4AgAOABSMAAAUmLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABRIuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABOEoAYAFBAABAwCABgACgAYjAAAFJiYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZjRaiM7DIbfZa5zYUm2ZfdVllLSNl0CIS3Z5sCh5N2PZEue5sAMuwN70/+zY/2jkTWeNF/T6+H5+vPpeH57/zU9/Piani/H0+n48+n0/rL/PL6fZfZrCvoHQp0eeDcBRNPSFcnUxmRjsnFE09w1gWnqmoOp+BbRkkxr12rztY8xRFMbA5lyV0TT3JXAtPtiDKbik1VL10Sm3DWDae7KwdTiuHbVfJvauPbPKcj6qpq6go21fk1LV823ae5Kto5sHdWu0cbR4jTfptxV821q18sWx7aObV2x6xUbV4kDUJBAwN0UAxkAOGQDlOSAFJJDNdB978AGERx8cfLwNGY8PGt4FGBw0DXSGbEEh2JQc4cUZDGiglwUJSoBOviMFgKTgFYCZWtSAYdqoJvWoXTIQX3kEln7G4sCG2hHdUgO1SD6moQG2t4ddLEUPOsNdigGhRyqQcungc2wbgoFAd2UDtkAo0M1IF+se9EgepRuAYFCcqgGugUd2EBT7eCLi4eXMePh1cOrhRfdHUIFNtDm71ANtJEaaN93KAbRalj06GiQgoPPaDeT9E9t9YkKbNAK1SAbaPdqJ1S9aAfrjapPWwefiT4TfSb5TPKZ7D7eY7X1WAM2aM3WwBcXX6y73JLXriOZgdBybaTJatZCyYnGnOZrpLFZKdKgMad9SNyInfSkMBrODIOKU6FB1amO61afAy+9EDt58QX8GtD6NN5uu8lfL0+fl8NB3y7f3jfyFvrYXw7nz+nhfD2ddtM/+9O1Lfr1sT83/dxf5FPp5sP5VVQM346ng9JtN0eH5VB5KWl5WrhwhmGR7j1gxSNkcgsAGg6Q6c4CVyySJ4EBhwFhujOgZQOuMZkD1zrngKXcWcRlC2KvY5S9GQb3ZUjL8YjgKSASLTnkZYcU2QxSLBvi80ggL19/7Q4IfCNR3sJbHDh6EZHTYhUh/FULyCV6Q/K3fvoTCzm73aJA3mRRaTwWNS5brDhAKe6AMS0+WLCyIylVL2cuOJdTTqh7j5W+4gz+bPHcl8C48ZRhXDxlylo1xiMOsq2LeUBduZM0OoNzmCua6/1JtXIvTMW3lSPiosXqvhKPckAMdclk/VZ4vhUMi3msHJqJ0c+bMudAkX57X8N4VvXVuNTiaw6Q4rypuMmhjFpi2JRDRJibc1MOKY67SAybHOo4LDLQFgeajxtKm+6C8jhuqGy5C3mmRkvGDfF1fJGonLfEo58Q8qV1S3zx/O++Q2zJ/3/xjzLavxwvd78n3NTpctw/nw42fLueX759+vnvh3/iv0d8XN5fDq/Xy0Gd5h8l5M8PeWfv5J/3R/1OKkN5OHfy5VSHoJ/Kg4YpP940mf8A","brillig_names":["is_profile_burned"]},{"name":"is_username_available","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEcuCIBHAAElAAAASyUAAABoLgIAAYBIKAIAAgSASCcCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgQAASYlAAACBScCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHAAEnAggECS0IAAktCgQKLQoDCy0KBQwtCgYNLQoHDgAIAAgAJQAAAi4tAgAAJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAIuLQIAAC0LBgELIgABgEQAByQCAAcAAAGkJwIIBAA8BggBJwIBBActCAAHLQoECC0KAwktCgUKLQoGCwAIAAEAJQAAA1wtAgAALQsDAQEiAAGARgAELQsEAwoqAwIBCyIAAYBEAAQkAgAEAAAB9SUAAARvLwoAAwABCioBAgMtCgMBJigAgAQEeAANAAAAgASAAyQAgAMAAAItKgEAAQX3ofOvpa3UyjwEAgEmJQAAAgUtCwQGCyIABoBEAAckAgAHAAACUCcCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAALoIwAAAmktCwMGLQsBBy0LAggtCwQJDSIABoBDAAonAgsBASQCAAoAAAKTJQAABIEuAgAHgAMoAIAEBAAEJQAABJMuCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARgAFDioGBQckAgAHAAAC0yUAAAUhLQ4KAS0OCAItDgUDLQ4JBCMAAANbJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA1wtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAASTLgiABQAJACIJAgoBIgAKgEUACy0OBQstDgkBLQ4HAi4MgEYAAy0OCAQjAAADWyYlAAACBS4IgEUABSMAAANsDSIABYBDAAYkAgAGAAAD3CMAAAOBLQsCBS0LBQYAIgYCBi0OBgUnAgYEBC0IAQcnAggEBQAIAQgBJwMHBAEAIgUCCCcCCQQEACIHAgo/DwAIAAotCwEFLQsDBi0LBAgtDgUBLQ4HAi0OBgMtDggEJi0LAwYMKgUGByQCAAcAAAPyIwAABF4tCwIGACIGAggAKggFCS0LCQctCwEIACIIAgoAKgoFCy0LCwkAKgcJCi0LAwctCwQJLgIABoADKACABAQABSUAAASTLgiABQALACILAgwAKgwFDS0OCg0tDggBLQ4LAi0OBwMtDgkEIwAABF4BIgAFgEYABi0KBgUjAAADbCoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABK4jAAAEuS4AgAOABSMAAAUgLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABQwuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABNsoAYAFBAABAwCABgACgAYjAAAFICYqAQABBUWnynEZQeQVPAQCASY=","debug_symbols":"tZjRbispDIbfZa5zATYG3Fc5qqq0TY8iRWmV06y0qvLua4PNNCvNaHeOzk3/D4L/8YCBNF/T6+H5+vPpeH57/zU9/Piani/H0+n48+n0/rL/PL6fpfdrCvonBp4eym6KMZnWroCm1kZro7UTmOauFE2paw6m4ltFK5lyV7Z+7m0IydTaEU1LVwDT3BWjafeFFEzFJ6vWroSmpWuOprlrCaYWV7ir5tvU2tw/xyDjWZW6Rmvr/DWtXTXfprkr2ji0cchdk7WTxWm+TUtXzbepPS9bXLFxxcZVe161NktcjAoSGGE3pYAGMTpkA5DkIiqQAxvouncoBik6+GDycBo9Hp41PAmU6KBjpDJSDQ7VgHMHCjIYQEEeChJF6gOkoD2yEKQ+DSo6VAMGBzEEMcxaRSDlkSE6kAMb6Js2SD5Ga7sBJQcdLNObdTkaFHAoBi2fBtWAvYdlDIbdVLR6Gmj5dKgGuvE6+GAt9Q4epUWDUYENtGw6FAMtnA7k4IOLhxfvqR5ePZw9XOsHZS2qLkqHaqB7tAMbQDJAcLA5rLpBO9hkVvKeImNQqqW2+ZHl5vasBmTQJqpB6pXA+tAGgA7VAL0HvSd5T/Ie8h5yH68xbjWmoEXbgRx8cPXBusqaPGvVofTE0HLtlHrWQuwEo0/z7dSmKzcqTmn0aR2iHqZBT1kjGjScMzlpVRoVp7bGncZzefT51Mfocy9Eg/wZ7X7AdLvtJr9Mnj4vh4PeJd9uF7lzPvaXw/lzejhfT6fd9Nf+dG2Dfn3sz00/9xf5VKr5cH4VFcO34+mgdNvN0WE5NKaqZ0QLFyYYFnTvEVc8Qka3iBGHQ8x4ZwErFpTNAcKcAgLdGeCyQeFE5lCY5xyg1juLtGyBxecxydoMg/tpoOV4gOgpACAuOeRlB0rFDCjVDfF5JJCXn7/2Bhh9IUHu3C0OJfkkQqHFWYzhj1rEXJMXZPlWT//HorCvRawxb7JgHNuC07LFikOs1R0g0eLGiisrQsQ+nVlultkjlHuPlbqSa9D3VpnrMhbYeMqU5VOmrs3G2OJRlnUxj8grb0KjMkoO84xmvj+pVt6lYPVlLQlg0WJ1XbHk8Sop8JLJ2pTKPwk8PKh82yj3hyasnJo8jl3mOBuU/359hLFZ5UbkpRpff480rypscqhjMiFsyiFBHNUJm3KgNN6CStzkwOO0yBG3OOB83iBtegvM47zBuuUtZFON7ZU2xPP4JsElb4kHPyI4bXp+DWND4O/l/6/4R2ntX46Xu58Pbup0Oe6fTwdrvl3PL98+/fz7wz/xnx8+Lu8vh9fr5aBO828Q8ueH3N87IHjUr6LSlO/BO9mV2oz6KaF8So83TeYf","brillig_names":["is_username_available"]},{"name":"pause_profile_creation","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAAB4HgIAAQEnAgIAEi8KAAIAAwoqAQMCJAIAAgAAAGclAAAAoScCAQAZJwICAAEwCgACAAEmKACABAR4AA0AAACABIADJACAAwAAAKAqAQABBfeh86+lrdTKPAQCASYqAQABBdVUQKFP/AOMPAQCASY=","debug_symbols":"nZRLjsMgDIbvwpoFz2BylVFVpSmtkBCJaDLSqMrdBzIhaRawmA02D3+Wfyy/0d3c5ufV+sfwQu3XG92Cdc4+r27ou8kOPp6+EUlLo1HLMVICtRCNXg1I1GqMNPkzsBpKOGqpSA5sDl1PlgWjDL5OwZjE/cgU849dMH5CrZ+dw+i7c/P66DV2frVTF+Itwcj4e7QR+LDOJG/BRzQph1KmSA6PPoUdIc8MWmYI4GJDCBBsJzT6RGBlAkjFNgJIUCVCvQ6hjjoaWapDVBhUyIyg6hCTKnZCyDJCSchSqIbIUiFNhcCBZ4JgRTFVrQyumr0OQfT/5OSfcqqSnHWGZjsDmC62Vg0iCM0MwVTxT2ilP4HwrAcQCSU5aKVBFXCdfwU0KSJ4tbvgaC/JmhPkEnddb8Np0iyJFmx3c2bbPmbff9xOP2O+yZNqDENv7nMwiXSMKxrXL8Yxg0uaP2mjMaeXJaX+BQ==","brillig_names":["pause_profile_creation"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2511765822595398882":{"error_kind":"string","string":"Recovery not initiated"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6759731346603734577":{"error_kind":"string","string":"Profile exists"},"8904759240416909843":{"error_kind":"string","string":"Already burned"},"9981700386366515877":{"error_kind":"string","string":"Invalid admin address"},"10309085656173016384":{"error_kind":"string","string":"Not recovery address"},"10455572626688361900":{"error_kind":"string","string":"Profile burned"},"11807246117437261849":{"error_kind":"string","string":"Burn disabled"},"12404158037908504363":{"error_kind":"string","string":"Not your username"},"13148562923741897405":{"error_kind":"string","string":"Profile creation paused"},"13354156717212309701":{"error_kind":"string","string":"Invalid visibility"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15090718400027906422":{"error_kind":"string","string":"Profile was burned"},"15371982489698173836":{"error_kind":"string","string":"Only admin"},"15691186487269729606":{"error_kind":"string","string":"Admin already initialized"},"15865011268275408360":{"error_kind":"string","string":"Username taken"},"16481276443224907681":{"error_kind":"string","string":"New username taken"},"17057512740490565102":{"error_kind":"string","string":"Admin already set"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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BAojAABS2wsiAAuARAAFJAIABQAAUPglAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUSIlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUUwlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUXYlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUaAlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUcolAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUfQlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUh4lAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUkglAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUnIlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUpwlAABpLy0KAQctCgIILQoDCS0KBAojAABS2wsiAAuARAAFJAIABQAAUsYlAABpLy0KAQctCgIILQoDCS0KBAojAABS2y0KCgQtCgcBLQoIAi0KCQMmKgEAAQVdz2PYW2N2MTwEAgEmKgEAAQXRbQBuRx1RdjwEAgEmJQAASM8tCAELJwIMBAQACAEMAScDCwQBACILAgwtCgwNLgyARgANACINAg0uDIBGAA0AIg0CDS4MgEYADS0IAQwnAg0EBQAIAQ0BJwMMBAEAIgwCDS0KDQ4uDIBGAA4AIg4CDi4MgEYADgAiDgIOLgyARgAOACIOAg4uDIBpAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4MgEUADC0IAQ4AAAECAS4MgEQADicCDwQQLQgAEC0KDREtCgsSLQoMEy0KDhQtCgQVAAgADwAlAABm8y0CAAAnAgQEDy0IAA8tCg0QLQoLES0KDBItCg4TLQoGFAAIAAQAJQAAZvMtAgAALQsOBAsiAASARAAGJAIABgAAVDsnAg8EADwGDwEnAgQEDy0IAA8tCg0QLQoLES0KDBItCg4TAAgABAAlAABoHC0C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uQsiAAuARAAFJAIABQAAW34lAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAW6glAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAW9IlAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAW/wlAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAXCYlAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAXFAlAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAXHolAABpLy0KAQctCgIILQoDCS0KBAojAABcuQsiAAuARAAFJAIABQAAXKQlAABpLy0KAQctCgIILQoDCS0KBAojAABcuS0KCgQtCgcBLQoIAi0KCQMmJQAASM8wCgAFAAQmJQAASM8tCAELJwIMBAQACAEMAScDCwQBACILAgwtCgwNLgyARgANACINAg0uDIBGAA0AIg0CDS4MgEYADS0IAQwnAg0EBQAIAQ0BJwMMBAEAIgwCDS0KDQ4uDIBGAA4AIg4CDi4MgEYADgAiDgIOLgyARgAOACIOAg4uDIBpAA4tCAENAAABAgEtDgsNLQgBCwAAAQIBLQ4MCy0IAQwAAAECAS4MgEUADC0IAQ4AAAECAS4MgEQADicCDwQQLQgAEC0KDREtCgsSLQoMEy0KDhQtCgQVAAgADwAlAABm8y0CAAAnAgQEDy0IAA8tCg0QLQoLES0KDBItCg4TLQoGFAAIAAQAJQAAZvMtAgAALQsOBAsiAASARAAGJAIABgAAXgEnAg8EADwGDwEnAgQEDy0IAA8tCg0QLQoLES0KDBItCg4TAAgABAAlAABoHC0CAAAtCw0ELQsLBi0LDA8tDgQNLQ4GCy0ODwwuDIBHAA4BIgAGgEgACy0LCwQLIgAFgFwABgsiAASARgALJAIABgAAYWcjAABebwsiAAWAXQAGJAIABgAAYT0jAABehAsiAAWAXgAGJAIABgAAYRMjAABemQsiAAWAXwAGJAIABgAAYOkjAABergsiAAWAYAAGJAIABgAAYL8jAABewwsiAAWAYQAGJAIABgAAYJUjAABe2AsiAAWAYgAGJAIABgAAYGsjAABe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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"set_initial_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"admin_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9981700386366515877":{"error_kind":"string","string":"Invalid admin address"},"15691186487269729606":{"error_kind":"string","string":"Admin already initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAACvJwICABMvCgACAAMcCgMFARwKBQQAHAoEAwEnAgQBAAoqAwQFJAIABQAAAHwlAAAA2CcCAwAACioBAwUKKgUEAyQCAAMAAACYJQAAAOonAgMAEjAKAAEAAycCAQABMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAADXKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXZwkr5hh8lRjwEAgEmKgEAAQWKhh+dt8FqpTwEAgEm","debug_symbols":"rZXbjoIwEIbfpddcdDrTE69ijEGthoSgQdhkY3j3bYWCbtJmd90b/hnKfM7J9M6Obj+cd3V7utxYubmzfVc3TX3eNZdD1deX1r+9Mx4eWrJSFszwSRQrdcEsTDJ5wL1rgqpJYfbBTiqIlcCDYWcD/Rsb1E5KelIp/AcyGHo2FLJShBBlgjGOBYtJ7vrOuZDjU9a+lmvVubZnZTs0TcE+qmZ4fHS7Vu1D+6rzpx7p2qNXDzzVjQvWWKzRPB1KwtIcTShoAchXAqQJACRnAoBeUwAtXhAijdDSxCS04nJBKPtCwAwBDUYCCZEiUK4M1Gqpg7hNMbJ16LUOwVMElSZILWaANGsGSPiLeeI6T5WaZ46AeiEQ8BTBpglWxkZaC0u80D9PgaRcUtDppcxtJXGI0yShk1sJmXEajrEQw6VJjRNye2nQxo0wNrkRkF1MMusfTD7N9Bsk21Ab0yCJyZmC+oeG6vcbat5vqP1rQ7feqw5193J9jIHW1dW+cbN7GtrD02n/eY0n8fq5dpeDOw6dC6T1DgL/3CAWaLbhVvEOiYJoO4af/gI=","brillig_names":["set_initial_admin"]},{"name":"set_kyc_verifier_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"kyc_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAB5HgIAAgEnAgMAEi8KAAMABAoqAgQDJAIAAwAAAG0lAAAAoicCAgARMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAAChKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXVVEChT/wDjDwEAgEm","debug_symbols":"nZTNroMgEIXfhbULhh8ZfJWmaayljQlBQ/UmN43vfsGI1gUs7oYzI/KROUzmQx7mPr9uvXsOb9JcPuTue2v7180OXTv1gwtfP4TGRUnS8IpgSDCIXEUDaXSQehWgYlNNGhAhABGDZalIAt4mb0zkfd0Q7h1bb9xEGjdbW5Gf1s7rT++xdatOrQ+7tCLGPYIG4LO3JkZLdZym+aPAmMTteIhVvSPkmQF5hkAuNoRAwXZCrU8EliegVGwjoESVIxTr4FTudXDGc3WIAgPEjgB1mAmKnRAyj1ASkxWqpjJXSF0gcOSJIFjWTFUqg6t6r0NQ/S87mf62U+bsLD+JpAcDswwoQQSFxBBMZd8ECv2JlCc/kErM2QGFBlXIdXoV1DSL4MXuwqO9JKtPkGvI2q73pwmzRJrv27s1W/qcXfe1O/2OaSdNqNEPnXnM3kTSMaYgrBfGK4bXOH9ioisO1yVe/Qc=","brillig_names":["set_kyc_verifier_contract"]},{"name":"set_privacy_settings_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"privacy_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAB5HgIAAgEnAgMAEi8KAAMABAoqAgQDJAIAAwAAAG0lAAAAoicCAgAQMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAAChKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXVVEChT/wDjDwEAgEm","debug_symbols":"nZTNroMgEIXfhbULfgYZfJWmaayljQlBQ/UmN43vfsGI1gUs7oYzI/LhHCfzIQ9zn1+33j2HN2kuH3L3vbX962aHrp36wYWnH0LjoiRpREUwJBhErqIZaXSQehVGYVNNGgYhYBCDZalIAt4mb0zkfd0Q7h1bb9xEGjdbW5Gf1s7rS++xdatOrQ+7tCLGPYIG4LO3JkZLdZym+aOMU8q34yHmB0KeGSzPABSwIQCB74Ranwg8T0Cp0kegRJUjlOsAfdRRq1wdUGAwkAnB1OEEU/yEkHmEkpisUDWVuULqAkGgSATgWTNVqQyh6r0OoPp/dopvO3XOzjJDw85gQmRbqwQByhIDuMr+E1boT6Qi+YFUYs4OVmhQhbsdCjXNIkSxu/BoL8nrE+Qasrbr/WnCLJHm+/ZuzZY+Z9d97U6/Y9pJE2r0Q2ceszeRdIwpFtYLFxXHa5w/MdGVYNclXv0H","brillig_names":["set_privacy_settings_contract"]},{"name":"set_profile_visibility","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"visibility","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13354156717212309701":{"error_kind":"string","string":"Invalid visibility"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBMJwAABAMnAgIEAScCAwQAHwoAAgADgEsuCIBLAAElAAAARSUAAAB+KAIAAQSATCcCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQAAIigAgEoAACcmJQAAAeYtCAECAAABAgEuDIBEAAItCAEDAAABAgEuDIBGAAMtCAEEAAABAgEnAgUAAi0OBQQeAgAGAScCBwAHJwIJBAotCAAKLQoHCy0KBgwACAAJACUAAAIPLQIAAC0KCwgLIgAIgEYABwsiAAeARAAJJAIACQAAAP0lAAADiS8KAAgABxwKBwkBHAoJCAAcCggHASQCAAcAAAEfJQAAA5sLIgABgEYABycCCAABCioBCAkSKgcJCgoqAQUHEioKBwUkAgAFAAABTSUAAAOtJwIFAAUnAgwEDS0IAA0tCgIOLQoDDy0KBBAtCgURLgiASQASLQoGEwAIAAwAJQAAA78tAgAALQoOBy0KDwktChAKLQoRCzAKAAEACycCAQAJJwIOBA8tCAAPLQoCEC0KAxEtCgQSLQoBEy4IgEoAFC0KBhUACAAOACUAAAO/LQIAAC0KEAUtChELLQoSDC0KEw0wCgAIAA0mKACABAR4AA0AAACABIADJACAAwAAAg4qAQABBfeh86+lrdTKPAQCASYlAAAB5i0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUuDIBGAAUAIgUCBS4MgEYABQAiBQIFLgyARgAFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy4MgEYABwAiBwIHLgyARgAHACIHAgcuDIBGAAcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAAHTS0CAAAnAgEEBy0IAActCgQILQoDCS0KBQotCgYLLQoCDAAIAAEAJQAAB00tAgAALQsGAQsiAAGARAACJAIAAgAAA00nAgcEADwGBwEnAgEEBy0IAActCgQILQoDCS0KBQotCgYLAAgAAQAlAAAIdi0CAAAtCwMBASIAAYBIAAMtCwMCLQoCASYqAQABBQLcbieAdhKdPAQCASYqAQABBTEEisAt600cPAQCASYqAQABBblTfsfsVhjFPAQCASYlAAAB5icCDAQNLQgADS0KBA4tCgYPAAgADAAlAAACDy0CAAAtCg4LJwIEABwKKgUEBgsiAAuARgAEJAIABgAABxIjAAAEBicCBgAeCioFBgwkAgAMAAAG6CMAAAQdJwIGAB8KKgUGDCQCAAwAAAa+IwAABDQnAgYAIQoqBQYMJAIADAAABpQjAAAESwsiAAWASQAGJAIABgAABmojAAAEYCcCBgAlCioFBgwkAgAMAAAGQCMAAAR3JwIGACYKKgUGDCQCAAwAAAYWIwAABI4LIgAFgEoABiQCAAYAAAXsIwAABKMnAgYAKAoqBQYMJAIADAAABcIjAAAEuicCBgApCioFBgwkAgAMAAAFmCMAAATRJwIGACsKKgUGDCQCAAwAAAVuIwAABOgnAgYALAoqBQYMJAIADAAABUQjAAAE/ycCBgAwCioFBgwkAgAMAAAFGicCDQQAPAYNAQsiAASARAAFJAIABQAABS8lAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABVklAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABYMlAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABa0lAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABdclAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABgElAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABislAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABlUlAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABn8lAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABqklAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABtMlAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAABv0lAAADiS0KAQctCgIILQoDCS0KCwojAAAHPAsiAASARAAFJAIABQAAByclAAADiS0KAQctCgIILQoDCS0KCwojAAAHPC0KCgQtCgcBLQoIAi0KCQMmJQAAAeYtCwQGCyIABoBEAAckAgAHAAAHbycCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAAAgCIwAAB4gtCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAAHrSUAAAmJLgIAB4ADKACABAQABCUAAAmbLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAB+0lAAAKKS0OCgEtDggCLQ4FAy0OCQQjAAAIdScCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAAh2LQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAJmy4IgAUACQAiCQIKASIACoBFAAstDgULLQ4JAS0OBwIuDIBIAAMtDggEIwAACHUmJQAAAeYuCIBFAAUjAAAIhg0iAAWAQwAGJAIABgAACPYjAAAImy0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAJDCMAAAl4LQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAJmy4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAAl4ASIABYBIAAYtCgYFIwAACIYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAm2IwAACcEuAIADgAUjAAAKKC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAoULgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAnjKAGABQQAAQMAgAYAAoAGIwAACigmKgEAAQVFp8pxGUHkFTwEAgEm","debug_symbols":"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","brillig_names":["set_profile_visibility"]},{"name":"set_quest_points_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"quest_points","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAB5HgIAAgEnAgMAEi8KAAMABAoqAgQDJAIAAwAAAG0lAAAAoicCAgAPMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAAChKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXVVEChT/wDjDwEAgEm","debug_symbols":"nZTBjoMgEIbfhbMHBgYZfJWmaWxLGxOihuomm8Z3XzBS6wEOe+GfEfnI/Ezmze72Oj8vXf8YXqw5vdnVd851z4sbbu3UDX34+mY8LlqxRlaMQkJB1CoGWGOC1KsAx00NawBDABiDZalYAl4mb23kfd0Q7h1bb/uJNf3sXMV+WjevP73Gtl91an3Y5RWz/T1oAD46Z2O0VPtpnj8KoLHejoe4xg9CHRmQZyBJ3BBIKD6E2hwIIk8gpcVGIEU6RyjXYeSnDgLI1YElBqrdit1M0OKAUHmEVpSs0DVXuULqAkFSqkOjyJqpS2VIvT8pcvM/O+nbTpmzs8ggSTtDZxlQgiCHxEChs28Chf4kLpMfxBXl7IBCgwY3THoVMjyLkMXuor29lKgPkHPI2lvnDxNmiTTftVdnt/Qx97ev3el3TDtpQo1+uNn77G0k7WMKwnoSshJ0jvMnJqaScF7i1X8=","brillig_names":["set_quest_points_contract"]},{"name":"set_recovery_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"recovery","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10455572626688361900":{"error_kind":"string","string":"Profile burned"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["set_recovery_address"]},{"name":"set_social_verifier_contract","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"social_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAB5HgIAAgEnAgMAEi8KAAMABAoqAgQDJAIAAwAAAG0lAAAAoicCAgAOMAoAAQACJigAgAQEeAANAAAAgASAAyQAgAMAAAChKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXVVEChT/wDjDwEAgEm","debug_symbols":"nZTLroMgEIbfhbULhosMvkrTNNbSxoSooXqSk8Z3P2DEy0lg0Q3DiHzw/0zmQx7mPr1ubffs36S6fMjdtda2r5vtm3ps+85//RAaBiVJxQuCPkEf5BI0kEr7UC4BqFijJhUIPwERJvNckAi8jc6YwDuc4M8dame6kVTdZG1Bfmo7LT+9h7pb4lg7v0oLYrqHjx74bK0Js7nYd9P0Vn8VzdbtABJ2hDwzIM0QyMWKECjYRij1icDSBJQqXgIlqhQhq0NyveuQKqVDZL2QG0LtToBiJ4RMI5TEaIUqqUwJKTMEjjwSBEuaqXIyuCo3HYLq7+xkRzt1ys48YzMDoDxo+V9aOYigEBmCqeSbQKY+kfLoB1KJKTsgU6AKt+pSqGkSwbPVhXt5SVaeIFef1U3rTh1mDjTX1ndr1vQ5dc1hdfwd4krsUIPrG/OYnAmkvU2BHy+MFwyvof+ERBccrnM4+g8=","brillig_names":["set_social_verifier_contract"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"nZPdioMwEIXfZa69MJo/fZVSStRYAiFKqguL+O47KclWF7KU3mQyzpzPo5lsMOhuvd+MG6cHtJcNOm+sNfebnXq1mMnh0w3KsJAa2roAQqFlGBi0AgOHttn3AlL/bfFah/YDALGz8tot0LrV2gK+lF2fTY9ZuWdclMdqWYB2A0YEjsbqsNuLl7rMS0lJiYxy3Avxi8DsBCF5iJA8IiSKEkCQk77K61nFop6x1zcQyt81IGuRDLAmZ4Dm9bRuop5y+ZEBSZOBRuYM8Lyel+kP8Ip/YqCpqghoapYzIP8xINMQifLPEVwxVb3xp9neA8ob1Vkd03F1/aG6fM+pku7G7KdeD6vXgXS4ILhecAir+rqHt/0A","brillig_names":["sync_notes"]},{"name":"toggle_burn_enabled","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAACRHgIAAQEnAgIAEi8KAAIAAwoqAQMCJAIAAgAAAGclAAAAuicCAQAaLwoAAQACHAoCBAEcCgQDABwKAwIBFgoCAxwKAwIAMAoAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAAC5KgEAAQX3ofOvpa3UyjwEAgEmKgEAAQXVVEChT/wDjDwEAgEm","debug_symbols":"rZXbbsMgDIbfhetcYMzB5FWmqkpbOkWK0ipLJk1V3n2QhdBcgLR1N7GB+qvtn8ODXdxpej+2/fX2weq3BzsNbde178fudm7G9tb72Qfj4aMtq7FiRrKavLGLIcVqWzHLfwwtBjiyGmRwaHXAR4EOjl0dEWdEmOHeQR8lFsdHCZznisUsjuPgXEjiKS2f7L0ZXD+yup+6rmKfTTctP/q4N/1ix2bwqx7p+ou3HnhtOxe8uUrRPB/qszRyDfe+FRtC7RmQZ0jCiJAkE0HbHUHkCaSMWAmkyOQIxTqUgK0OhTZXhywwQKqIAJOaCUbsECqPMIpiK4zmKleILhCQMBKkyDbTlMpAo7c6JLd/ayc8tVNCrp1lhk1bS0NWEuCvawLwsiggXlYF8B9kKZdiUimCZxGFLZqOmqKUA0r8ha5ap71RuDJKm1TybX9JYfK6UuHW4CaKQpww2wxburq2m8uabDPKSaDeklCUvfxKohLaKCrZrKhCFI8JpXOihN5BDn7UnNth9+bNgTa0zalz6/A69een1fHrHlfim3kfbmd3mQYXSOnhBP99E1QhHsID6Af+QUB9mMNffwM=","brillig_names":["toggle_burn_enabled"]},{"name":"transfer_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAB0HgIAAgEnAgMAEi8KAAMABAoqAgQFJAIABQAAAG0lAAAAnTAKAAEAAyYoAIAEBHgADQAAAIAEgAMkAIADAAAAnCoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEF1VRAoU/8A4w8BAIBJg==","debug_symbols":"lZTLroMgEIbfhbULhuvgqzRNYy1tTIgaqic5Mb77QSNeFpCcDT8j8sH8TGYiL/scP4+mfXdfUt4m8vSNc83n4bq6GpquDV8nQpdBS1LygmAIMIhcxQApTRC1ClCxqSEliHkuSOQ8Bm/tgjmBw3F95W07kLIdnSvIT+XG9advX7WrDpUPq7Qgtn0FDcB34+wym4tjN01vBQ5CbNvDXLEdIa8MSDME8ogQKA6CMhcCSxNQarYRUKJOEfJ5GNjzYNSk8hAZBggZEaAPM0GzC0KmEVpitEIrKlOJqAyBI48EwZJm6lwaXKs9D3Gy4l924slOgJSdWQbj6mBImSytHETQ/R6C6eSbQKY+ke73QCoxZQdkClQjN/FV0NAkgmerC4/ykkxdIPcQVXXjL41lXmi+qZ7ObuF7bOvT6vDbx5XYmHrf1fY1eruQju4EYbwxVjB9D/0HlgALTu/zcvQf","brillig_names":["transfer_admin"]},{"name":"unblock_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"address_to_unblock","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAARSUAAABpKAIAAQSASScCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcEAAEmJQAAAP8eAgACAScCAwAGJwIFBAYtCAAGLQoDBy0KAggACAAFACUAAAEoLQIAAC0KBwQLIgAEgEYAAgsiAAKARAADJAIAAwAAALglAAACoicCAwQFLQgABS0KBAYtCgEHAAgAAwAlAAABKC0CAAAtCgYCCyIAAoBGAAELIgABgEQAAyQCAAMAAAD4JQAAAqIwCIBGAAImKACABAR4AA0AAACABIADJACAAwAAAScqAQABBfeh86+lrdTKPAQCASYlAAAA/y0IAQMnAgQEBAAIAQQBJwMDBAEAIgMCBC0KBAUuDIBGAAUAIgUCBS4MgEYABQAiBQIFLgyARgAFKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy4MgEYABwAiBwIHLgyARgAHACIHAgcuDIBGAAcAIgcCBy0OBActCAEEAAABAgEtDgMELQgBAwAAAQIBLQ4FAy0IAQUAAAECAS4MgEUABS0IAQYAAAECAS4MgEQABicCBwQILQgACC0KBAktCgMKLQoFCy0KBgwtCgENAAgABwAlAAACtC0CAAAnAgEEBy0IAActCgQILQoDCS0KBQotCgYLLQoCDAAIAAEAJQAAArQtAgAALQsGAQsiAAGARAACJAIAAgAAAmYnAgcEADwGBwEnAgEEBy0IAActCgQILQoDCS0KBQotCgYLAAgAAQAlAAAD4i0CAAAtCwMBASIAAYBHAAMtCwMCLQoCASYqAQABBQLcbieAdhKdPAQCASYlAAAA/y0LBAYLIgAGgEQAByQCAAcAAALWJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAA24jAAAC7y0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACicCCwEBJAIACgAAAxklAAAE9S4CAAeAAygAgAQEAAQlAAAFBy4IgAUACgAiCgILACoLBgwtDgUMASIABoBHAAUOKgYFByQCAAcAAANZJQAABZUtDgoBLQ4IAi0OBQMtDgkEIwAAA+EnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAD4i0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAABQcuCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyARwADLQ4IBCMAAAPhJiUAAAD/LgiARQAFIwAAA/INIgAFgEMABiQCAAYAAARiIwAABActCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAABHgjAAAE5C0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABQcuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAE5AEiAAWARwAGLQoGBSMAAAPyKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAFIiMAAAUtLgCAA4AFIwAABZQuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAFgC4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAFTygBgAUEAAEDAIAGAAKABiMAAAWUJioBAAEFRafKcRlB5BU8BAIBJg==","debug_symbols":"tZjdaiM9DIbvJcc5sOQfWb2VpZS0TZdASEs2+eCj5N5XsiUnWZihO2VP6mc0o3dkSban+Vy9bp/PP592h7f3X6uHH5+r5+Nuv9/9fNq/v2xOu/eDWD9XQf8AyBDXMubVQ5YRg41+zX2M0UbqY0Ib7TqDjeJXZSyxjwQ2ch9rWj1AUGADjg7UAQM4FANwi4bZQd0lcEQyiNkgRYcqIC+NKohRIRvotDu4Bd2Cw8IG0S3Jn0nFILtyljAwCVA1qOjgt9gtbJYU0KEYgFvAn8HoYMopJgc20CkjKpBBRodiUIJDdmADcvcWvIKWqYNb2J9h9ZJS55AcqkELvkExaFlt4A+jP6wd1cEtyd3bLBRaehtkB397cffiD5M/TP726paq7qSg7tISuZVAoLSWUGgt0UBDZQU2aCVoQAYRHLKDP5zcPbklu7s2SZTuLVqCBhpGhPWKtEUjKrCBNkADRIdiEHXRSteR5icmhezABpqfDmRA/kwNDtVAixuzAneo2pANdOl1IIMWTwO3aDZiUWADTUID7cMOZFD84ZaEBu6l7RelTLVGBzJgcMgO3IFDdDB3BreAuTOCQ3ZQdyk3awUbaPt1IAMtXIdqUIoBWQ6ZkoMlk6tZILTNlZU0Qyk0yoPYSbNlVHs/QGjv7kROBQcNGw0bDVsdtjpsPPS852Tvh0F5EDtBHDQ8Wu25kWQiNVuLvlO1eYBGbzRsGr2R+qKSrlmjYdP2TO1M0mVrxE48lNnz186JTgCDyAlx0LCNeuCoB456tBOkU26+l8t65Wfn0+m43erReXOYyhH7sTluD6fVw+G8369X/2325/bQr4/NoY2nzVHuiub28CqjCL7t9luly/rqHaZduVY2b+ZAQyDfK8C0QqralU1B9nccCoXvFHBaQRYxmkLNlaYU5mbBusXaLHKZmkWaVpDej6agLToU5IvjyxJQPQipdZ6UKNMScg55LTPnGwmpzK0ETUsU9noSlMkYvprLMtkR/P1c8vdzCfClZJaKaTKZMNOaVMCzSfWqQLgomxwn19dcX6XgQcj3MU1GAXlmiQU9CfsSC7lOLTGY6U2qcXRW5TApQXNVTTWPzshYFix1yD4RDNfNRj6v76OY6S3i5EHQbUmw1vsdayaKSN5a8tl8VbgvKs40JyJ4EIgxTkrM9KZ8z/pekeoSgTJCKDMRzE0igi90jDfV/BsJSp5JpDydyvJPJaBUP8OAbtrqbySIvRxQoSyS4Dj2TU6TEnOLI4xUyEcaL1GAPDKhG8wShVrG1h0WxZDwZsNbFENOYxbyD9wiBR61KBCXKMRrNWNeNItYxiEY65JZUPF2oJIW+PM4yJmW9COj7zCcFr2/hnF4xu/F/4f/o1xtXnbHux+vLqp03G2e91u7fDsfXm7unv7/8Dv+49fH8f1l+3o+blXp+guY/Pkhn/lrpPio/x3JpWzXGfUC9B4luVceLxrKbw==","brillig_names":["unblock_address"]},{"name":"unpause_profile_creation","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBEJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAPyUAAABAKAIAAQSARCcCAgQAOw4AAgABJiUAAAB4HgIAAQEnAgIAEi8KAAIAAwoqAQMCJAIAAgAAAGclAAAAoScCAQAZJwICAAAwCgACAAEmKACABAR4AA0AAACABIADJACAAwAAAKAqAQABBfeh86+lrdTKPAQCASYqAQABBdVUQKFP/AOMPAQCASY=","debug_symbols":"nZTNjoMgEMffhTMHYEAGX2XTNNbSxoSoobrJpvHdF1zReoDDXpjhY36T+TOZN7nb2/y8dv1jeJH6601uvnOue17d0DZTN/Th9E1YXCpDaqBES1JjMGY1qEhtKDHsz+BqOANScxkd3By+niwLJQl8nby1kfuRKeQfG2/7idT97Bwl342b10evselXOzU+3DJKbH8PNgAfnbPRW+gRzfKhXBiutvDgA+wIdWbwPEMiyA0hUYqdUJkTQeQJqLTYCKhQ5wjlOipx1IEsV4csMLjcpeD6IHAtTgiVR2iFSQpdMZUrpCoQACERpMiKqUtlgK72OiQz/5NTfcopcnKWGMCYTgxgUmZbqwSRjCeGFDr7J7zQn8gg6YFMYU4OXmhQjWDSr6BhWQQUuwuP9lKiOkEuYde0nT9NmiXSfNfcnN22j7lvP26nnzHdpEk1+qG199nbSDrGFQ/rlwAq8BLnT9wYCvyyxNS/","brillig_names":["unpause_profile_creation"]},{"name":"update_token_uri","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_uri_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10455572626688361900":{"error_kind":"string","string":"Profile burned"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBXJwAABAMnAgIEAScCAwQAHwoAAgADgFYuCIBWAAElAAAARSUAAADLKAIAAQSAVycCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQAAHCgAgEoAAB4oAIBLAAAfKACATAAAISgAgE0AACIoAIBOAAAlKACATwAAJigAgFAAACcoAIBRAAAoKACAUgAAKSgAgFMAACsoAIBUAAAsKACAVQAAMCYlAAACey0IAQIAAAECAS4MgEQAAi0IAQMAAAECAS4MgEYAAy0IAQQAAAECAScCBQACLQ4FBB4CAAUBJwIGAAcnAgsEDC0IAAwtCgINLQoDDi0KBA8tCgYQLgiATgARLQoFEgAIAAsAJQAAAqQtAgAALQoNBy0KDggtCg8JLQoQCi8KAAoABhwKBgsBHAoLCgAcCgoGASQCAAYAAAFtJQAABhwnAgYABCcCDgQPLQgADy0KAhAtCgMRLQoEEi0KBhMuCIBMABQtCgUVAAgADgAlAAACpC0CAAAtChAKLQoRCy0KEgwtChMNLwoADQAGHAoGDgEcCg4NABwKDQYBCyIABoBEAA0kAgANAAAB3SUAAAYuJwIGAAMnAhEEEi0IABItCgITLQoDFC0KBBUtCgYWLgiASwAXLQoFGAAIABEAJQAABkAtAgAALQoTDS0KFA4tChUPLQoWEDAKAAEAECcCAQAJJwITBBQtCAAULQoCFS0KAxYtCgQXLQoBGC4IgFAAGS0KBRoACAATACUAAAZALQIAAC0KFQYtChYQLQoXES0KGBInAgEAATAKAAEAEiYoAIAEBHgADQAAAIAEgAMkAIADAAACoyoBAAEF96Hzr6Wt1Mo8BAIBJiUAAAJ7JwIMBA0tCAANLQoEDi0KBg8ACAAMACUAAAm4LQIAAC0KDgsLIgAFgEkABAsiAAuARgAGJAIABAAABeEjAAAC6QsiAAWASgAEJAIABAAABbcjAAAC/gsiAAWASwAEJAIABAAABY0jAAADEwsiAAWATAAEJAIABAAABWMjAAADKAsiAAWATQAEJAIABAAABTkjAAADPQsiAAWATgAEJAIABAAABQ8jAAADUgsiAAWATwAEJAIABAAABOUjAAADZwsiAAWAUAAEJAIABAAABLsjAAADfAsiAAWAUQAEJAIABAAABJEjAAADkQsiAAWAUgAEJAIABAAABGcjAAADpgsiAAWAUwAEJAIABAAABD0jAAADuwsiAAWAVAAEJAIABAAABBMjAAAD0AsiAAWAVQAEJAIABAAAA+knAgwEADwGDAELIgAGgEQABCQCAAQAAAP+JQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAQoJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAARSJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAR8JQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAASmJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAATQJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAT6JQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAUkJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAVOJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAV4JQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAWiJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAXMJQAACzItCgEHLQoCCC0KAwktCgsKIwAABgsLIgAGgEQABCQCAAQAAAX2JQAACzItCgEHLQoCCC0KAwktCgsKIwAABgstCgoELQoHAS0KCAItCgkDJioBAAEFMQSKwC3rTRw8BAIBJioBAAEFkRmn6HEOxaw8BAIBJiUAAAJ7JwIMBA0tCAANLQoEDi0KBg8ACAAMACUAAAm4LQIAAC0KDgsLIgAFgEkABAsiAAuARgAGJAIABAAACX0jAAAGhQsiAAWASgAEJAIABAAACVMjAAAGmgsiAAWASwAEJAIABAAACSkjAAAGrwsiAAWATAAEJAIABAAACP8jAAAGxAsiAAWATQAEJAIABAAACNUjAAAG2QsiAAWATgAEJAIABAAACKsjAAAG7gsiAAWATwAEJAIABAAACIEjAAAHAwsiAAWAUAAEJAIABAAACFcjAAAHGAsiAAWAUQAEJAIABAAACC0jAAAHLQsiAAWAUgAEJAIABAAACAMjAAAHQgsiAAWAUwAEJAIABAAAB9kjAAAHVwsiAAWAVAAEJAIABAAAB68jAAAHbAsiAAWAVQAEJAIABAAAB4UnAgwEADwGDAELIgAGgEQABCQCAAQAAAeaJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAfEJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAfuJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAgYJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAhCJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAhsJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAiWJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAjAJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAjqJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAkUJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAk+JQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAloJQAACzItCgEHLQoCCC0KAwktCgsKIwAACacLIgAGgEQABCQCAAQAAAmSJQAACzItCgEHLQoCCC0KAwktCgsKIwAACactCgoELQoHAS0KCAItCgkDJiUAAAJ7LQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS4MgEYABQAiBQIFLgyARgAFACIFAgUuDIBGAAUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLgyARgAHACIHAgcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBQAAAQIBLgyARQAFLQgBBgAAAQIBLgyARAAGJwIHBAgtCAAILQoECS0KAwotCgULLQoGDC0KAQ0ACAAHACUAAAtELQIAACcCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgstCgIMAAgAAQAlAAALRC0CAAAtCwYBCyIAAYBEAAIkAgACAAAK9icCBwQAPAYHAScCAQQHLQgABy0KBAgtCgMJLQoFCi0KBgsACAABACUAAAxtLQIAAC0LAwEBIgABgEgAAy0LAwItCgIBJioBAAEFAtxuJ4B2Ep08BAIBJiUAAAJ7LQsEBgsiAAaARAAHJAIABwAAC2YnAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAL+SMAAAt/LQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAAC6QlAAANgC4CAAeAAygAgAQEAAQlAAANki4IgAUACgAiCgILACoLBgwtDgUMASIABoBIAAUOKgYFByQCAAcAAAvkJQAADiAtDgoBLQ4IAi0OBQMtDgkEIwAADGwnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAMbS0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAADZIuCIAFAAkAIgkCCgEiAAqARQALLQ4FCy0OCQEtDgcCLgyASAADLQ4IBCMAAAxsJiUAAAJ7LgiARQAFIwAADH0NIgAFgEMABiQCAAYAAAztIwAADJItCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAADQMjAAANby0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAADZIuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAANbwEiAAWASAAGLQoGBSMAAAx9KgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAANrSMAAA24LgCAA4AFIwAADh8uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAOCy4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAN2igBgAUEAAEDAIAGAAKABiMAAA4fJioBAAEFRafKcRlB5BU8BAIBJg==","debug_symbols":"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","brillig_names":["update_token_uri"]},{"name":"update_username","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"old_username_hash","type":{"kind":"field"},"visibility":"private"},{"name":"new_username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"12404158037908504363":{"error_kind":"string","string":"Not your username"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16481276443224907681":{"error_kind":"string","string":"New username taken"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["update_username"]}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztlanProfileRegistry"}},{"name":"fields","value":{"fields":[{"name":"username_to_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"profile_id_of","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"token_uri","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"profile_burned","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"profile_visibility","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"blocked_addresses","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"has_profile","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"profile_created_at","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"profile_last_updated","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}},{"name":"username_last_changed","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}],"kind":"struct"}},{"name":"username_change_count","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}],"kind":"struct"}},{"name":"recovery_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000c"}}],"kind":"struct"}},{"name":"recovery_requested_at","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000d"}}],"kind":"struct"}},{"name":"social_verifier_contract","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000e"}}],"kind":"struct"}},{"name":"quest_points_contract","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000f"}}],"kind":"struct"}},{"name":"privacy_settings_contract","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000010"}}],"kind":"struct"}},{"name":"kyc_verifier_contract","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000011"}}],"kind":"struct"}},{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000012"}}],"kind":"struct"}},{"name":"admin_initialized","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000013"}}],"kind":"struct"}},{"name":"total_profiles","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000014"}}],"kind":"struct"}},{"name":"total_burned_profiles","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000015"}}],"kind":"struct"}},{"name":"next_profile_id","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000016"}}],"kind":"struct"}},{"name":"username_change_cooldown","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000017"}}],"kind":"struct"}},{"name":"recovery_delay","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000018"}}],"kind":"struct"}},{"name":"profile_creation_paused","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000019"}}],"kind":"struct"}},{"name":"burn_enabled","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001a"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"address_to_block","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::block_address_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::block_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::burn_profile_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::burn_profile_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::change_admin_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::change_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"lost_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"new_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::complete_recovery_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::complete_recovery_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::constructor_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"username_hash","type":{"kind":"field"}},{"name":"token_uri_hash","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::create_profile_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::create_profile_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::emergency_set_admin_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::emergency_set_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"username_hash","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_address_by_username_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_address_by_username_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_admin_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_kyc_verifier_contract_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_kyc_verifier_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_privacy_settings_contract_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_privacy_settings_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_profile_id_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_profile_id_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_profile_visibility_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_profile_visibility_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_quest_points_contract_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_quest_points_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_recovery_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_recovery_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_social_verifier_contract_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_social_verifier_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::get_token_uri_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_token_uri_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_total_burned_profiles_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_total_burned_profiles_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::get_total_profiles_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::get_total_profiles_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::has_profile_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::has_profile_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::initialize_admin_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::initialize_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"lost_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::initiate_recovery_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::initiate_recovery_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::is_admin_initialized_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::is_admin_initialized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"profile_owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"blocked_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::is_blocked_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::is_blocked_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::is_burn_enabled_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::is_burn_enabled_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"user","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::is_profile_burned_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::is_profile_burned_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"username_hash","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::is_username_available_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AztlanProfileRegistry::is_username_available_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::pause_profile_creation_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::pause_profile_creation_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_initial_admin_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_initial_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"kyc_verifier","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_kyc_verifier_contract_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_kyc_verifier_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"privacy_settings","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_privacy_settings_contract_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_privacy_settings_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"visibility","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::set_profile_visibility_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_profile_visibility_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"quest_points","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_quest_points_contract_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_quest_points_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recovery","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_recovery_address_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_recovery_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"social_verifier","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::set_social_verifier_contract_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::set_social_verifier_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::toggle_burn_enabled_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::toggle_burn_enabled_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::transfer_admin_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::transfer_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address_to_unblock","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AztlanProfileRegistry::unblock_address_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::unblock_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AztlanProfileRegistry::unpause_profile_creation_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::unpause_profile_creation_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_uri_hash","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::update_token_uri_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::update_token_uri_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"old_username_hash","type":{"kind":"field"}},{"name":"new_username_hash","type":{"kind":"field"}}],"kind":"struct","path":"AztlanProfileRegistry::update_username_parameters"}}],"kind":"struct","path":"AztlanProfileRegistry::update_username_abi"}]}},"file_map":{"104":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"},"107":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/storage.nr","source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"},"146":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"163":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"172":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"20":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"25":{"path":"std/meta/expr.nr","source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"},"270":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"288":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"325":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"343":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"},"344":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"363":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"43":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"50":{"path":"/home/babi/aztlan_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n// CONTRACT 1: SOULBOUND PROFILE REGISTRY\n// Privacy-focused, non-transferable identity system\n#[aztec]\npub contract AztlanProfileRegistry {\n    use dep::aztec::macros::{functions::{public}, storage::storage};\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n    use dep::aztec::protocol_types::traits::FromField;\n\n    #[storage]\n    struct Storage<Context> {\n        // Core mappings\n        username_to_address: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        profile_id_of: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Soulbound NFT data\n        token_uri: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        profile_burned: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        \n        // Privacy settings\n        profile_visibility: Map<AztecAddress, PublicMutable<Field, Context>, Context>, // 0=private, 1=public, 2=friends\n        blocked_addresses: Map<AztecAddress, Map<AztecAddress, PublicMutable<bool, Context>, Context>, Context>,\n        \n        // Metadata\n        has_profile: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        profile_created_at: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        profile_last_updated: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Username change tracking\n        username_last_changed: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        username_change_count: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Recovery system\n        recovery_address: Map<AztecAddress, PublicMutable<AztecAddress, Context>, Context>,\n        recovery_requested_at: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Contract references\n        social_verifier_contract: PublicMutable<AztecAddress, Context>,\n        quest_points_contract: PublicMutable<AztecAddress, Context>,\n        privacy_settings_contract: PublicMutable<AztecAddress, Context>,\n        kyc_verifier_contract: PublicMutable<AztecAddress, Context>, // NEW!\n        \n        // Admin\n        admin: PublicMutable<AztecAddress, Context>,\n        admin_initialized: PublicMutable<bool, Context>, // NEW: Track if admin is set\n        \n        // Stats\n        total_profiles: PublicMutable<Field, Context>,\n        total_burned_profiles: PublicMutable<Field, Context>,\n        next_profile_id: PublicMutable<Field, Context>,\n        \n        // Config\n        username_change_cooldown: PublicMutable<Field, Context>,\n        recovery_delay: PublicMutable<Field, Context>,\n        profile_creation_paused: PublicMutable<bool, Context>,\n        burn_enabled: PublicMutable<bool, Context>,\n    }\n\n    #[public]\n    fn constructor() {\n        // Initialize basic settings without admin\n        storage.total_profiles.write(0);\n        storage.total_burned_profiles.write(0);\n        storage.next_profile_id.write(1);\n        storage.username_change_cooldown.write(30);\n        storage.recovery_delay.write(259200); // 3 days in blocks\n        storage.profile_creation_paused.write(false);\n        storage.burn_enabled.write(true);\n        storage.admin_initialized.write(false); // Admin not set yet\n        \n        // Initialize contract addresses as zero\n        storage.social_verifier_contract.write(AztecAddress::zero());\n        storage.quest_points_contract.write(AztecAddress::zero());\n        storage.privacy_settings_contract.write(AztecAddress::zero());\n        storage.kyc_verifier_contract.write(AztecAddress::zero());\n        storage.admin.write(AztecAddress::zero());\n    }\n\n    // NEW: MANUAL ADMIN INITIALIZATION (Only callable once!)\n    #[public]\n    fn initialize_admin() {\n        assert(!storage.admin_initialized.read(), \"Admin already initialized\");\n        \n        // Method 1: Using FromField trait\n        let admin_address = AztecAddress::from_field(\n            0x30390871bfa13ca49d58be1741dfb724562db24b52ca967a1d4a7d0b08faced4\n        );\n        \n        storage.admin.write(admin_address);\n        storage.admin_initialized.write(true);\n    }\n\n    // ALTERNATIVE: Set admin with parameter (safer approach)\n    #[public] \n    fn set_initial_admin(admin_address: AztecAddress) {\n        assert(!storage.admin_initialized.read(), \"Admin already initialized\");\n        assert(admin_address != AztecAddress::zero(), \"Invalid admin address\");\n        \n        storage.admin.write(admin_address);\n        storage.admin_initialized.write(true);\n    }\n\n    // NEW: EMERGENCY ADMIN SETTER (Anyone can call, but only works if admin is zero)\n    #[public]\n    fn emergency_set_admin(new_admin: AztecAddress) {\n        let current_admin = storage.admin.read();\n        assert(current_admin == AztecAddress::zero(), \"Admin already set\");\n        \n        storage.admin.write(new_admin);\n        storage.admin_initialized.write(true);\n    }\n\n    // PROFILE CREATION - SOULBOUND\n    \n    #[public]\n    fn create_profile(\n        username_hash: Field,\n        token_uri_hash: Field\n    ) {\n        let caller = context.msg_sender();\n        \n        assert(!storage.profile_creation_paused.read(), \"Profile creation paused\");\n        assert(!storage.has_profile.at(caller).read(), \"Profile exists\");\n        assert(!storage.profile_burned.at(caller).read(), \"Profile was burned\");\n        assert(\n            storage.username_to_address.at(username_hash).read() == AztecAddress::zero(),\n            \"Username taken\"\n        );\n        \n        let profile_id = storage.next_profile_id.read();\n        \n        // Create soulbound profile\n        storage.username_to_address.at(username_hash).write(caller);\n        storage.profile_id_of.at(caller).write(profile_id);\n        storage.token_uri.at(caller).write(token_uri_hash);\n        storage.has_profile.at(caller).write(true);\n        storage.profile_created_at.at(caller).write(1); // Block number\n        storage.profile_last_updated.at(caller).write(1);\n        storage.username_last_changed.at(caller).write(1);\n        storage.username_change_count.at(caller).write(0);\n        storage.profile_visibility.at(caller).write(1); // Default public\n        storage.recovery_address.at(caller).write(AztecAddress::zero());\n        \n        storage.total_profiles.write(storage.total_profiles.read() + 1);\n        storage.next_profile_id.write(profile_id + 1);\n    }\n\n    // BURN FUNCTIONALITY - Right to be forgotten\n    \n    #[public]\n    fn burn_profile() {\n        let caller = context.msg_sender();\n        \n        assert(storage.burn_enabled.read(), \"Burn disabled\");\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        assert(!storage.profile_burned.at(caller).read(), \"Already burned\");\n        \n        // Mark as burned (keep data for username uniqueness)\n        storage.profile_burned.at(caller).write(true);\n        storage.has_profile.at(caller).write(false);\n        \n        // Clear sensitive data\n        storage.token_uri.at(caller).write(0);\n        storage.profile_visibility.at(caller).write(0);\n        storage.recovery_address.at(caller).write(AztecAddress::zero());\n        \n        // Update stats\n        storage.total_burned_profiles.write(\n            storage.total_burned_profiles.read() + 1\n        );\n    }\n\n    // RECOVERY SYSTEM\n    \n    #[public]\n    fn set_recovery_address(recovery: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        assert(!storage.profile_burned.at(caller).read(), \"Profile burned\");\n        \n        storage.recovery_address.at(caller).write(recovery);\n    }\n\n    #[public]\n    fn initiate_recovery(lost_address: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(\n            storage.recovery_address.at(lost_address).read() == caller,\n            \"Not recovery address\"\n        );\n        assert(storage.has_profile.at(lost_address).read(), \"No profile\");\n        \n        storage.recovery_requested_at.at(lost_address).write(1); // Should be block\n    }\n\n    #[public]\n    fn complete_recovery(\n        lost_address: AztecAddress,\n        new_address: AztecAddress\n    ) {\n        let caller = context.msg_sender();\n        assert(\n            storage.recovery_address.at(lost_address).read() == caller,\n            \"Not recovery address\"\n        );\n        \n        let requested_at = storage.recovery_requested_at.at(lost_address).read();\n        assert(requested_at != 0, \"Recovery not initiated\");\n        \n        // Transfer profile (but keep it soulbound to new address)\n        let profile_id = storage.profile_id_of.at(lost_address).read();\n        storage.profile_id_of.at(lost_address).write(0);\n        storage.profile_id_of.at(new_address).write(profile_id);\n        storage.has_profile.at(lost_address).write(false);\n        storage.has_profile.at(new_address).write(true);\n        \n        // Clear recovery\n        storage.recovery_requested_at.at(lost_address).write(0);\n    }\n\n    // PRIVACY SETTINGS\n    \n    #[public]\n    fn set_profile_visibility(visibility: Field) {\n        let caller = context.msg_sender();\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        assert(\n            (visibility == 0) | (visibility == 1) | (visibility == 2), \n            \"Invalid visibility\"\n        );\n        \n        storage.profile_visibility.at(caller).write(visibility);\n        storage.profile_last_updated.at(caller).write(1); // Should be block\n    }\n\n    #[public]\n    fn block_address(address_to_block: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        \n        storage.blocked_addresses.at(caller).at(address_to_block).write(true);\n    }\n\n    #[public]\n    fn unblock_address(address_to_unblock: AztecAddress) {\n        let caller = context.msg_sender();\n        \n        storage.blocked_addresses.at(caller).at(address_to_unblock).write(false);\n    }\n\n    // USERNAME MANAGEMENT\n    \n    #[public]\n    fn update_username(\n        old_username_hash: Field,\n        new_username_hash: Field\n    ) {\n        let caller = context.msg_sender();\n        \n        assert(\n            storage.username_to_address.at(old_username_hash).read() == caller,\n            \"Not your username\"\n        );\n        assert(\n            storage.username_to_address.at(new_username_hash).read() == AztecAddress::zero(),\n            \"New username taken\"\n        );\n        \n        // Update mappings\n        storage.username_to_address.at(old_username_hash).write(AztecAddress::zero());\n        storage.username_to_address.at(new_username_hash).write(caller);\n        \n        storage.username_last_changed.at(caller).write(1);\n        let change_count = storage.username_change_count.at(caller).read();\n        storage.username_change_count.at(caller).write(change_count + 1);\n        storage.profile_last_updated.at(caller).write(1);\n    }\n\n    #[public]\n    fn update_token_uri(new_uri_hash: Field) {\n        let caller = context.msg_sender();\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        assert(!storage.profile_burned.at(caller).read(), \"Profile burned\");\n        \n        storage.token_uri.at(caller).write(new_uri_hash);\n        storage.profile_last_updated.at(caller).write(1);\n    }\n\n    // ADMIN FUNCTIONS\n    \n    #[public]\n    fn set_social_verifier_contract(social_verifier: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.social_verifier_contract.write(social_verifier);\n    }\n\n    #[public]\n    fn set_quest_points_contract(quest_points: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.quest_points_contract.write(quest_points);\n    }\n\n    #[public]\n    fn set_privacy_settings_contract(privacy_settings: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.privacy_settings_contract.write(privacy_settings);\n    }\n\n    #[public]\n    fn set_kyc_verifier_contract(kyc_verifier: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.kyc_verifier_contract.write(kyc_verifier);\n    }\n\n    #[public]\n    fn toggle_burn_enabled() {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.burn_enabled.write(!storage.burn_enabled.read());\n    }\n\n    #[public]\n    fn pause_profile_creation() {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.profile_creation_paused.write(true);\n    }\n\n    #[public]\n    fn unpause_profile_creation() {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.profile_creation_paused.write(false);\n    }\n\n    #[public]\n    fn transfer_admin(new_admin: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        storage.admin.write(new_admin);\n    }\n\n    // NEW: CHANGE ADMIN FUNCTION (Better than transfer)\n    #[public]\n    fn change_admin(new_admin: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        assert(new_admin != AztecAddress::zero(), \"Invalid admin address\");\n        \n        storage.admin.write(new_admin);\n    }\n\n    // VIEW FUNCTIONS\n    \n    #[public]\n    fn get_profile_id(user: AztecAddress) -> Field {\n        storage.profile_id_of.at(user).read()\n    }\n\n    #[public]\n    fn get_address_by_username(username_hash: Field) -> AztecAddress {\n        storage.username_to_address.at(username_hash).read()\n    }\n\n    #[public]\n    fn get_token_uri(user: AztecAddress) -> Field {\n        storage.token_uri.at(user).read()\n    }\n\n    #[public]\n    fn has_profile(user: AztecAddress) -> bool {\n        storage.has_profile.at(user).read()\n    }\n\n    #[public]\n    fn is_profile_burned(user: AztecAddress) -> bool {\n        storage.profile_burned.at(user).read()\n    }\n\n    #[public]\n    fn get_profile_visibility(user: AztecAddress) -> Field {\n        storage.profile_visibility.at(user).read()\n    }\n\n    #[public]\n    fn is_blocked(profile_owner: AztecAddress, blocked_address: AztecAddress) -> bool {\n        storage.blocked_addresses.at(profile_owner).at(blocked_address).read()\n    }\n\n    #[public]\n    fn get_recovery_address(user: AztecAddress) -> AztecAddress {\n        storage.recovery_address.at(user).read()\n    }\n\n    #[public]\n    fn is_username_available(username_hash: Field) -> bool {\n        storage.username_to_address.at(username_hash).read() == AztecAddress::zero()\n    }\n\n    #[public]\n    fn get_social_verifier_contract() -> AztecAddress {\n        storage.social_verifier_contract.read()\n    }\n\n    #[public]\n    fn get_quest_points_contract() -> AztecAddress {\n        storage.quest_points_contract.read()\n    }\n\n    #[public]\n    fn get_privacy_settings_contract() -> AztecAddress {\n        storage.privacy_settings_contract.read()\n    }\n\n    #[public]\n    fn get_kyc_verifier_contract() -> AztecAddress {\n        storage.kyc_verifier_contract.read()\n    }\n\n    #[public]\n    fn get_total_profiles() -> Field {\n        storage.total_profiles.read()\n    }\n\n    #[public]\n    fn get_total_burned_profiles() -> Field {\n        storage.total_burned_profiles.read()\n    }\n\n    #[public]\n    fn get_admin() -> AztecAddress {\n        storage.admin.read()\n    }\n\n    #[public]\n    fn is_burn_enabled() -> bool {\n        storage.burn_enabled.read()\n    }\n\n    // NEW: Check if admin is initialized\n    #[public]\n    fn is_admin_initialized() -> bool {\n        storage.admin_initialized.read()\n    }\n}\n"},"69":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"71":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/utility_context.nr","source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"},"97":{"path":"/home/babi/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr","source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"}}}