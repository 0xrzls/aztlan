{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"AztlanQuestPoints","functions":[{"name":"_record_quest_completion","hash":"17575391454843020238","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"},{"name":"quest_id","type":{"kind":"field"},"visibility":"private"},{"name":"points_earned","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15353289549725070351":{"error_kind":"string","string":"Quest already completed"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["_record_quest_completion"],"brillig_names":["_record_quest_completion"]},{"name":"complete_quest","hash":"17824547258399816562","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"profile_id","type":{"kind":"field"},"visibility":"private"},{"name":"quest_id","type":{"kind":"field"},"visibility":"private"},{"name":"points_earned","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"rZdLbuMwDIbv4nUWIqlnr1IUhZt6CgOGE7jJAIOidx8qtiS7gIhMPJswfn0mf1I09dW8d2/Xj9d+/HX6bJ6ev5q3qR+G/uN1OB3bS38a+exXo+KPNs0THhptZ+Nm42cT2HwfGog3Ah/ANx8lxutl6rp4ZQXlV53bqRsvzdN4HYZD87sdrrebPs/teLOXduKr6tB04ztbBv7qhy7++z6Up1X9Ue1wediizo+DNvcCDMECMM6uAO5eABrtFgJawIJQeoMgAYE6SYBoC8Jto9B1AqlgFgKB9TWCqRPABEhx8H8quUDvNxArQKzxiWGdywhSWz+cgEBvEwJDeAhBlhJCg6oiZDWMLmqsFP2pBkilAZhiwViSNUcA9utxL4PL4zHGnaKKenBx5zp3dT0khPZQVhtVVxsIVaoBUm41mBKK9fd6Ac5kQT2VQMy2b4EXEFAKDEJpXSzMlhHE5WazH7z06lWKQjAu6NQ7XAhUZwjVQS41ME2rWLZyIAp5JUjlhYS2iiBJ0dVKUaGGkNJqXW5fTtlaWlFqHF5RbqNeWVurLhQKlMjmbq6p2s1R6IEeISE8Gqwn1f+Hwgg7C4PU7sIgsXVRbl201uIHQijPkJtfcPYRAPenJAQoH3b6sE7GP+hw3wIRs+HKpOJMPaHS19mFskCgLqbfmw2/V0q/P52SDqFUZdD1jic3mxCKlspVm40MceVjBkg1iJbmz9w4NUF1ipbdgKKHB1eNRUvzZzAhd/BgwVQhTpratFmNbd485onDXCHBu7qqQvMMxuQRAf1Du5sQUihWraa227j0woftsZ+2G0EgfjFv8/RszGxsfC1bt1gfF/Jh3geyRRU/VWxhsbhYWqyOsxZbs1i7WObFjwwyT3PmMMyW1O2rGwOb+vZt6KJr0fvreEye8uHlzzldSZva83Q6du/XqYtRlZ0t+/HMzVXjCzvNZ54NHIx9yfvZeIoHHORTUZi/","names":["complete_quest"],"brillig_names":["store_in_execution_cache_oracle_wrapper","notify_enqueued_public_function_call_wrapper"]},{"name":"constructor","hash":"12922887977604273748","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_registry","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"social_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VWTYvCMBBN2shu1v2AXZa9rP8h9YP26EG9evDgOdhWPIgi4tmfbsUJHcd46kRwoEzCTN68NxlCpbhYVH0S1gp8LG7N5QzBm2aWMGKZkDzlk/CMAvG8GgYJA3PPnKgOeA0+QvGYUbQmdTnxM9NPtUcfI/+eBkwVGL8VBt+8AM7oWONjLa7uB+wl6qU742J4rsYkhmdwArHX6vsU9foL1prUCjETmC93T388/F2tNmj9I1oV6g8Tj+S9wvgFLHtYT7eLTV7M9pudXRbz3WpfCGL4AikpLOjeA0IvjlFMt7EYSfaRJ+9BYjJ2MbEnD1tb1E+5Ol6fGzKISjNjHKcY8FvC/x+iUBzn/8P+DelyXjXgWaY2KXu2tAOb5/2F/Sb4uG/nPp0AwghD11gJAAA=","debug_symbols":"tZTBjoMgEIbfhbMHBlTAV2kag4oNCUFDdZON8d0XWnX1gId1e+EHhvnI/JnMhBpVjY9S27Z7ouI2ocppY/SjNF0tB91ZfzshHBbIUZElCNhbOCoAexVvJf4N+HsCQec5QSuhHJxSAbBD+o966ZQdUGFHYxL0Jc34evTspX3pIJ2PerKyjVcPbLVRYTcnv9k4ngqE0yUbKNANkB0JcEJIMayElLCNAIwcECSO4JjmC4LjjG+IXBwINE5gnIqFwLjAMUJ6UgakPFvrgIzkMcaZmTTdrKAMx8zMr5vJLpvJL5spPm2mYJsVkEc78x9aE673JlxvTvhzd979SdbaHebRHGhOy8qo5diOtt5Fh+9+jazzrHddrZrRqUDaDTW/3ghNCL/P4bcf","names":["constructor"],"brillig_names":["constructor"]},{"name":"create_quest","hash":"3987058646601657001","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"_quest_id","type":{"kind":"field"},"visibility":"private"},{"name":"_quest_data","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUzU7DMAxOaSoI40fi7wISr5DSlPW4A5yR4AmiJuEEQxPi3EeHCEd13W6TtsRSZEef8/mzkzZj/5bB8sbBH7CxhZwFeLmflRG5ZEqdWSKdgyFnbL0F7B68IOc9nkdsWJC6MfkbqR7FRH8R9VcCcSbgfwj8PA2/PASep27Iz0jdUzb8ePGZgOE39gzYEeAhPoNYEL4U9441xZ7b5YT+UGsGvd7A/uRvnUOsfz5evtqlsW/209gVHicd/Sajz4LFa63xcq9Gcr+XK/1uX602VHOBYkYwHPM1eRQvJmZRECzkXoP3476DeMb63xbveo5Y1z9vpAw95F2vK2dj4wjH+bewP0Y94jksdtTp5rp0lXa61saoVl8Qfm/4mcaub+paKalL5Vwrq6bdVv8XLqUbXBgIAAA=","debug_symbols":"nZPNjoMgFIXfhTULfr3oqzRNQy02JAQN1UkmxncfcPxd4KIbjni5HzlH74he5jm8H9Y37QdVtxE9g3XOvh+urXVvWx/fjoikhUpUcYxogSoVBf5FoaqMUs7C4sFymjBaux99MCY1H3Dxkk4H43tU+cE5jH60G+ZDn077WXsdYpVgZPwragQ21pn0NOG9m+RbeaH40s2B0A0gzwSaJwjFxUIQSrCNUJQnAssTlAS2EJRUkCNcuQBONhdC5VyIPIFSIRcCpbAHSYGdEDKPAKnWIKAgMmejuCDw7WOAYNko4coGh2LzIUj5VZhsD1OSU5j3uNO1Dae/fkqsYPXTmWXbDL4+VPvfbq2sU9OFtjavIZhEOoxOXG+MYQb3OCs0bRTm5D6lq/8A","names":["create_quest"],"brillig_names":["create_quest"]},{"name":"get_public_points","hash":"17086344827876705849","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1Zy27sRBBtx+MZex43A2GFBNJdIXb2ZB6J2Ay6CYEVEnyBmZmwQhchxNpfgMSKBUv2bPgMkJD4CRb8BNNJV3J8XPY84uYKcUsate2qrldXVVf3BOYeAvez0IFvDPJt6cb0aZC1yCsNFD0bjdAmPHcPiXs/AXzYouGJoktb/C/SaZ6Yqs0t6n+eOJ4+/SM8PfBPe47Px8Ujf7bFwsiUkwPnxA4vz2cwx8InwFvm+/Tbdt0vPfstOzP1vpKYe1F4kX0u/K+Av2mPfyr8r/3o/8D/I8ffh+43fnTPBuY+xj+Atca1b9GWufCOjBdb5pLTXVMFwfVINuJiwGl7iUBI72iT5fEh8GU61gc35R7RipyIaC1IrAUkv6PMt3BVlHkJ/XPQ+3v3PNz+3nLP+Xdfffr16uV68/m3L7/Jv9x8tsnXQY2e7Cumq2tAQqPHBdKGCo9I4RE2yIuI5n032nh5zz3LupwAb/G1pbt03zzmyeJ1nlT1acoTXt+mPBGdOsp8C1dFmZfQz0HvY/Okzlf75gnHJvLE2Bwp8mSOrfeyp3SKR3xb8bW4eGzYQ8c/MtVYQPkR0S/dex/0l7HzBD1vF3l2e57f5rN8vZ6u8jeJvyE/4b44MtV8596Pa+/ySD0JplrchDW+Eb/57BUDU80zrr/oS/FdpOg6NtVaXre3oZxIkfNv8eL1trB0Y3oYTPjDSJHLcdaF7y2u62zfOBP5feN1n3qIsy7pU7dm2t4lc8emundwbPQUOT1Fzn+FF8Yo76OC10aRw99YjtZrNtXJY+UgTURyohblIK/roiyn26Ic5HVV3I+S29x3Ld17+jS44N4NQXB4d8Vx0ye9EDcAHK/PEHBdwo0Ap/lSQOsjxU/Wnh+AL9MJJIqcFv274NqDoPXN7N+E9EIc+p79i75n/6LvsWdk0PwrdPv699RU/dslfqLDvr230LvPvnMk5X4QZf2f4ueYGPkd+DKdgBYjIfELSSbHiNyDCa997naRztrb9rkinaxX881ke/RZzLPJ5fqQc4XY0SVd0CcSE/hd20Miov/RjRK7Mflqeay9BFrexA32hQ32hYp9L2rs+9WNlvanPeSdmmr9CAiHPjohnLY/Cg+JqWiHDbIWmHcWlm5MnwZZRPr87EZrV+SESY7KeZvrnIUO4No8y1o9YtADdb3zX1H26wBwoULPdyFDhV6rcWNT3SMj4qWdFXFNb0hX8WFXoUd+HMe/uNH65t2grB/mVJ90R9tjwmk9s9a3J6Dzb+7Z8znz4L0uIBzmIZ/99u1Tm/4M1/Y68cWhex33QIjrKXZodahD8jBvhf+ryFv8L5rzFnM0VOg5b3fl+XVxP45NdS05vjFnEsKh3B7hcN1vSB7Gi6wN5kzdfaF2prTz/gB+uI64f+Bc3gOF/i/Q5U/3fGqq9YzjS6tLrIsxet2rOzdzPHqsIVOthgQk21O/s/c9mcjvm2q++7gni0kfjqET8k/iaW2aaoB2b/XG9vfMVNcM9RNeWg+sxTvX2qZ+UKu1Wi3hOrNPLdF6Dq2WDMxhvbJWJ7iOIP3fbrT4k6BsP8rjuqzFlFYLhD5R6NG/oqu2ByaEq/ufsS624ga9mvYXTS+MPZzLsnfZoP2P2nSeeIV7/Ezb49F23uObem0LvAYjhV7rv8dEjz7X8pJ7X5Q7IBzmE+dsXV8s+dK0P2Kdld5B+9+rC3ylB2j7PmI1m3+xms7ydJPZ18mu+4hT0akAu4rynJ57lzM60wu/iOiHwaO9zyC27mgVeZbunQa6oGa846F86xTlb0lRpQ+LKr3I7hdVHQU3ABzmhoWhe0d/IS/RIyL6t6E2W4hhjswfK/Jjkl/SW/nG98EDhX6g0Nv1OXOTHu48QHbbfc2dTOKP31g3iR0f93zblFqs8kWWXU6zzTSb7cqrfwBbAe3DhS0AAA==","debug_symbols":"tZjbbtpKFIbfhWsuZh3mlFepoogkpEJCJKKwpa2Id+8sZv12qGSrNe0N/+dgf57DmrHD5+p1+3z+/rQ7vL3/WD18+1w9H3f7/e770/79ZXPavR/aXz9XwT64ffJ6xdSDe0gP7RF7pB65R+lRVw9xvZLQg3pwj2ah0LJpqJ0r0TP11HY2aUv2FE/1jJ7JM3sWz9oztptTbkme7Cme1o12v2QdaMcpexbP2jMHT/JkT/FUz+jpvmy+0rJ41p4leJIne4qnekbP5Om+4r7ivuq+ar7Ukj3FUz2jZ/LMnsWz9qQQAARggDmrgQIiIAEyoACqAwUAARgAM8FMMBPMBDPBTDAzzAwzw2xVK2TQzMIGEZAAGdDMIgbVwWq4AwEYIAAFREACZICZ1aA6WAFLNLBzbHithDtUByviDgSwu2cDu1cxSIAMKIDqkAKAAAywXthAJQVEQAJkQAFUB1seGgwIwAABKCACEiADmlBtmmx9dCAAAwSggAhIgAwoAJgrzLZU1Kbb1koHASggAhIgAzC81YeXQwAQwE4W20HtpmpAAAYIQHslsNV8hwTIgAKoDlbzHQjAAAHAzDAzzAwzw8wwW6lfG2+lrte/REDyNlthdyiA6qDW5WRAAAZYl7OBAiIAZoVZYVaYIwYzYjAjBjNiMG1f7xABMMer8HJZr/DEezodt1t74H15BLYH48fmuD2cVg+H836/Xv232Z+vJ/342Byuedoc27etbLeH15ZN+Lbbb40u6/HqMH2pcsl+tQrFQRBvDTRtaBuuuKFtpzIY2nr+bUVbI1C0eZhUyLQixopRSIV1VIR8o9BpRU7khpzLKMi8aCyFp8YyzQ2E1baPZQ6TjcgzvYhF0Y0UxrFM9cZQZgxSMKFZmacMda4bktPQDw11yjHbjzz2g8OUgWbKKmZ2QyxjE0TltydUtA4TmmVycchfWB1y//KgeP/6oPQvF8jX8axhcjzL/SuE6t1LhMPda4TpLyySmWa0Vy43cBgbIRxvWzFTW7kO45lrHeuTS7l1zGycksMwq2Nl8e2k8kxxthcHNKK9McikYqY2o2LrjVqWCNLQhDTTgrlOCKEk2utKWqTIipHkHCeHUsI/VbR3ayyPtsJ4kSJXTEd7e06LFFWGjbPqpGLOEIahaP8C1iUGijpuNrzIUIY1zmFRG5Sx69LXneYPDFGHXsRMiwx1mItEssQg42xKXNQLScNDUMqSXrS9ftj1dcH1dXiS17ykHitjh6m66P4F7b/ZqJe0/5frH9vR5mV3vPn97WKm427zvN/64dv58PLl29P/H/gGv999HN9ftq/n49ZM44947eMbJ11ziY/2M0w7jHWd1A7IvmuLpD1wHi/WlJ8=","names":["get_public_points"],"brillig_names":["get_public_points"]},{"name":"get_quest_count","hash":"16552793417368834515","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzY4bRRDu2fHYHnuNTeBBZnbH692bpWwWbkjkCQbbiwRCAQTckObIhccACYmX4MBbREJC4oByyS1SIkVxr7uyn7+pGXvl7vyUZPVMV3VVdf11TTsyG4jcz0IH5hhkbu7G7DDIPfLKIkXP1k1oC166MXXjEeBjjxtPFV188T/PiovU1PfsUf/T1PEMaR/hGYB/1nN8Pqlu+fNeLIzMdnLgmr7Dy/M9WGPhU+At60Pabe3388B2yz8yzbaSmLtfBZF9Kvwvgb/xxz8T/g/C6P+a/1UY/vnQbOJwZfRY82mrkdn2PfpD5OJB4nGfhVa/Y5pD+QMTNicikif6sH3ED2K7RNF1ouAw1xCHchJFzpvixf62MHdjdjc44YmRohPHWRfmPfp1um+cifyBYqMQcdYlfZp8JrbrKbpOFBzHRk+R01PkvE+8JEZHph6zUcMocniO5XC9QzmxRzlIk5CcxKMc5CVnosjpepSDvC6rzSi5jX6duzE7DArh3QfdPObphdiIe3C03wBkc0wOSS/EHQOOfT8CXJdwHwAO84Ehpne0kx2/Br5MJ5Aqcjza93xEeiGw7TX7DkgvxKHt2b5oe7Yv2l7LAwHNvmKnfe07VuR0Sb7w7NC8wGW1GROif+jGwDmS3QO+hmSlyv48yp7xuYgwUvbN8ZOSXojD2OL4wdhCfzFoMSJ0Vq/fgS/TCWgxEhM/rV9FHvKdMlbWdxr0SxRaPr/lfd/YFPqFG60N/nHPNic/ds/lT9989u3i0XL18IdH35dfrj5flcuoQU+2O9PFDXTWh+L/TrVNP3fz2QEwO7+9yIqrWztwTKD8hOi/cu8YizJ2DtDzelbm16fldTktl8tiUXIOWzgCO+G3qMRQl3SR56aapfUGXLO+c+PbrFna/uKW/cXK/u437O9XN1raH/eQNzb18zciHNroiHDa2Sk8JKaSHXsQX2DNszB3Y3YY5Anp87Mb7b7+dc9SHyUv0CYhc3gNhdXjP9ADdb2xX7Vt1yHgYoWea+ixQq+dLxOix3MponfkhT69Il3Fhl2FHvlxHP/iRmubF6Qf5tSAcLj3PuG0byHteywFnX9zz4HvD+7cZ0SEwzzkb/p9e9i2P3O0PkNscdc+g/tPxGnf8lod6pA8zFvh/zbyFr/jOG8xR2OFnvN2V54/qDbjxNR9yfGNOZMSDuX2CId+vyJ5GC/iG8wZPte1ewfZg133B/BDP+L5gWv5DBT6v0CXP93z2NTrGceXVpdYF2P0utd294nxGLCGFFoNiUh2oH5n7/tPkT8w9XwPcf/ZJ304hvheOg3km7YaoN1Hfmg29zDsM9RPeGk9sBbvXGvb+kGt1mq1hOvMPrVE6zm0WjI0d+uVtTrBdQTp/3ajxT+m/aM8rstaTGm1QOhThR7tm5BszImUcFoP0BZb/Ra92s4XTS+MPVzLsnftgXO+ScY7cMZPtTMe985nfFuvbYF9MFLotf57QvRocy0vufdFuUPCYT5xzjb1xY9pH7v+Z5LeQfs/swt8pQfwfR+RnSwXZ6uT9ZXJ7Cw/uVjuuo/wLX8xPftiUUzLbJXfaLNL/lhsUt3iMf4t9Ny73BEwvfBLiP5/oV3/nrhniatEkWfpnrfQRQ3jDQ9lrlNtz6VVnT6u6vQie1DVdRTcEHCYmxaO3TvaC3mJHgnRP3Pv4pM+rJH1E0V+n+Rv6a3MYY4yr1iZE3rrn6fCz424d9991Y1M4o9zrJvEToi8WqfUbFHO8vyiyFdFPt2VV68AYjcOGsUoAAA=","debug_symbols":"tZfdauMwEIXfxde5kEbSjNRXWUpJ23QJhLRkk4Wl5N13JqPj1As21LA3PV/i6ot+RrL9Obzuni8/n/bHt/dfw8OPz+H5tD8c9j+fDu8v2/P+/ajffg7B/sQ2PMhmoOARPcgjeWSP4sEe4lE93JLcktRSNcgjeWSP4sEe4lE92i1y8HBLdkt2S3ZLVgtrsId4VI92ixI8ogd5JI/s4ZbilqKWplE92i04eEQP8kge2aN4sIdb2C3sFnGLuEXcIm4Rt4hbxC3iFlFLjJqqibQZaugZe1JPVcWkmXuWntxTetaezbOFnrEn9TRf1sw9zacL27in9Kw91Ufajxj0C0oG9o22jDEAIoAACaA/Q8VAvcQGFdA6WIE6RAABEiADtL8kBgwQQAW0Dla0DhFg5mqQABlQAAwQQAW0DlbB1AwIkAAZUAAMEEAFtA5W0w4wF5itslMwyIACYIAAKqB1YEwvY3oZ08uYXivmpNUYrYCTLbeVsEMGFAD3SrBSdkBtWDXfwMrZIQIIkAAZUAAwV5grzBXmBnOD2Ur61nmr6XT7RgC199nK2IBCAESADTkbJEAG2JCLAQMEUNEc5ghzhDkSIAEyoAAYIACY6Sa8XjcDzvan82m3s6P9y2Gvt4CP7Wl3PA8Px8vhsBl+bw+X2z/9+tgeb3nenvSq1sLu+Kqpwrf9YWd03dxbh/mmWSu3t866tKOgTA1x3hADp27Q4yKNBi3BiYIWFIW7QZdsFCQqE0GaF0jLpRuktXsfqNaJIs8rkmAWc8p3wXQaynx70oXHICilOQPPG8q4EiXXFe157ADP//7SCFLEQlIiXmOQjEkkKbOzGMN/VUSuGQUpX+rpOwppWAs95niVoqVxW7Q8r1gw6BEJA+Uyu7HiwoqU0jCdXOk+nTHI1LFQV8IRe0vudan3k1VnTJPZM6YuzcW4wfV5I8z2IraFcZSxLoTDfT65Tc+phZFIqlhUyUSzisVVTcLjUHJoc5Kl2grjJtGHtzZXW0sGfeK4zyetMtRxGBRW9SETCit+ncxvGEoeR1EkrjK0cZdyTGsM6b7PU1k1isTjPk91zSi0nMfCzivat/EO3oTXtCdszpZX/X5F/yc37zX9/6f9o37avuxPk3foq5lO++3zYdc/vl2OL1+unv984ArewT9O7y+718tpZ6b7i7j++UH6KE8lPNoLlH6MIW70mcg+Rrtaol5Nj1frzF8=","names":["get_quest_count"],"brillig_names":["get_quest_count"]},{"name":"is_on_leaderboard","hash":"5671702161409292170","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZwY7jRBBtj+MkTiYkLHyIPZNMZm6RdnbghsR+gUkycFkWoRXi6DsXPgMkJH6CA3+xEhISB8SFGxKIOOliXp6fnYxis1BS1HZXdb3q6qrqdidwOwr8r6AO9DFZ38K3yWmUNqgrCYSdtZNQAwL/EPv3M+CHDU48FrY0pf86md7ErjznBu2/jL3ONv1jOlvQn/S8nvfyB/08l4JGbj85cEzf8+35CYwp6H3QbePb9Ntm3a9b9lv6jqv2lcXc07wV7EvTfwv6XXP6E9P/rB37/9F/147+dOh2cfiJ07HWpK9Gbn/tcT0MFzeSBuc5VfU7pD7EH7h2cyIgPLOH/WPrYL6LhK0TwcNcQx7iRALn39LF613QwrfJ4+iCO0bCJo6zLvQ3uK6zY+PM8AfCR23EWZfsqVoz811P2DoRPI6NnsDpCZz/ky6L0ZErx2xQ0RoO9zEO1zvECRvEQZmIcKIGcVCX7YmG020QB3Xd5rvWchvXdeHb5DS6Mt19sK3BPL0xH/EZHP03AGyOySHZhbxz4PHaj4DXJd5bwMN8YArpHf1UtJ+CXpYzigVOg/69HpFdSOx75d8B2YU89D37F33P/kXfqzwwUv41Px3r37HA6RK+6exQv9Ftvmsjkn/u25ZzJHkCeh1hxWJ+DWLPeV9EGol5c/zEZBfyMLY4fjC2cL2YVIyYXGHXt6CX5YxUjISkT51XUYd9p4zF+E6FfZGQ5f3b3o+NTZNf+rbwwU/+ucjJd/1z9sWLDz5bvlytn796+Xn28frDdbYKKuxkv7NcWCEXOu1LlA1ded6h0IHjzkhHESsWZ518X8/C9ycn0Pz64cIs9PojV449xI9I/oV/x5i3tnOCnffzLL2/zO6zWbZaTZcZ1woH/uJvXovVLtliz1W1UZ1BuDa+8u2brI1qfmHN/EIxv6cV8/vat4Xsl0fgjWk8xvRY+OiMeGqPNh0WU9GBOdhaYG0taOHb5DRKI7LHw27n9bN/tjpseYE+aTOHNzQt7PgF7EBbt/7L9/06BF4o5LlWnwt5tY9NSB73v4DeUReu6R3Zaj7sCnnUx3H8lW8L3/xF9mFODYiHc+8TT31zqe++GGz+xj+3fE/x6PNMQDzMQ747OPasXPenkTrPmC8ee57hcy7y1J2BqkMdwsO8Nf1vIm/xe5HzFnM0FPKct4fy/Fm+ayeuvJYc35gzMfEQt0c8XPc7wsN4sbXBnOF9Xd1v2ByKcd+BPlxH3D9wLO+BJv8D2PK9fx67cj3j+FJ1iW1xTte9ujtWjMcWa8hU1ZCAsFs67xx9z2r4A1fO9zbuWftkD8cQ33/HLa1NXQ1Q955vu919D68Z2me61BlYxTvX2rrzoKq1qpZwnTmmlqgzh6olQ/e4s7KqE1xHUP5H3xb81zR/xOO6rGJK1QKTj4U8+jcibMyJmHjqDFAXW/0au+r2F2UXxh6OZexDc+Ccr8L4D+zxM7XH49x5j687axfEazAS8ur8PSF59LnKSz77Iu6QeJhPnLNV5+LXNI9D/2fZ2UH9b9oFvXYGaPo+IrlYLa/WF5srk/lVenGzOnQf0TT+cnb10XI6y5J1urXmEP7YfJI/8DH+C+r5d7sjYHnTF5H8rya7+f3mny2uIoFXyP1ZIxdUtFsdoq+T7/fFeVk+zMvyhj3IyzYabwg8zM2Czv07+gt1mR0Ryf/h321N+jDGxk8Efp/w9+wWfaX7QyE/FPLF+vxu+nyLc2/6XLXFJP3Yx7ZZ7LSRV5uUmi+zeZreTNP1NJ0dyqu/Abtre7EtKQAA","debug_symbols":"tZjbauNKEEX/Rc9+6OpLVXd+ZQjBSZzBYJzgsQ8cgv/9VLl6S/YBiRnBvGQvWdFSX6pbsr+H993r5efL/vjx+Wt4+vE9vJ72h8P+58vh82173n8e9dPvIdgfasOTbIYYPMgjeiSP7FE82EM8qodbkluSWqpG9Ege2aN4sId4VI92ixw83JLdkt2S3ZLVwhrsIR7Vo92iBA/yiB7JI3u4pbilqKVpVI92Cw4e5BE9kkf2KB7s4RZ2C7tF3CJuEbeIW8Qt4hZxi7hF1EKkqRqKm6GGntQz9lQVJc3cs/TkntKz9myeLfSknrGn+bJm7mk+ndjGPaVn7am+qO2goMKYDQgQO5B9UgzsEzZIgAwoAAbonaLegaxAYzUgQAQkQAYUAAMEoE2OzaB1sKJ1IEAEJEAGqDkFAwYIoAJaBytkBwJEgAoTGRQAAwRQAa2D1bQDASIgAWAuMFt9J5sdq3CHCmgdrM4dCBABGF7G8DKGlzG8VtIpGdhNbbqtkB0EUAGtV4KVswNqwwraIQEyoAAYIIAKgLnB3GBuMDeYG8xW1bfGW1mnYpthAJC3OVoZOyRABliX2YABArAu33bX1oECAGaCmWAmmKkAGCCACmgdbIE4wBxvwut1M2Dbfzmfdjvb9e+eA/p0+Nqedsfz8HS8HA6b4Z/t4XL7p19f2+Mtz9uTntWy3R3fNVX4sT/sjK6b6eowf2kuGVfnwnUUlEcDzRsocOoG3UnSaNDqfFDEBUXhbtDZHAUplgdBmhdIy6UbpLWpDbHWB0WeVyQZx0FnZhQ8DkOZv14nF03Q6U1zBp43lCxdUHJdcT2PDeD5+y/1IBEmMqbIawwyFlOUMjuKFP6qgrhmFKTc1dOfKKRhLnQH5FWKlsZl0fK8YsGguycMMZfZhUULM1JKw3ByjdNwUpBHx0JdCRPWlkx1qQ+WVXtMLbN7TF0ai3GB64tHmG0FtYV+lLEuhMPUDG6P+9RCTyRVTKrkGGcVi7OahMeu5NDmJMtdkakrMcy2Y2HLLBKx29SpDSmn351VCuOsUrhTxN9+9uhLZZ4mNa4y1HEsY1jVhhxR3XQ/o39gKHnsRRFaZWjjVsGU1hjStNmksqoXicfNJtU1vdA1NZZkXnF9G18jmvCa6yN2iJZX3b+i/Q9vEGva/7/rn/Vo+7Y/PXzHv5rptN++Hnb98ONyfLs7e/73C2fwG8HX6fNt93457cw0/VCgf37oE3sTS3q273V6qItzQ6HZIdlZXWix8PPVGvMf","names":["is_on_leaderboard"],"brillig_names":["is_on_leaderboard"]},{"name":"is_quest_completed","hash":"15916531656782700988","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"},{"name":"quest_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+VazY7jRBBux3ESJxkmsAgkjjwAsjPJZIZTpJ1hgAsSPIE3yXBCixBC4uYbEicOHLlz4TFAQuIlOPAWKyGmJ12Tz5/LjjNxs1ptSaO2XdX111XV1Z0JzBY6d3+Be+7CNwahWboxOQ7SFnklPvUMWtQzAD07pQdQHp81/HvuISYa+zls0fiY5LbJ/yKZPYtNEVrW/ywGnh74T4V/1w//pO/4fJwX+RuSe+LeMX5kjuAwjj5xuMHd3xtm9/w28LPwKcgV3jHxazkmMs9rlj6p0F9ss/A09yL7TPhfAX/THv9E+F/70f+B/0eOvw/db/zono7MNsZnsNa49i3aMhfekfFiy7nkdM+UQXB9ko24AeCwtjOE9I42WR4fAl+mY32wRvaJVugjorUgsRaQLV1lvoWrvMhL6N8HvX9wz55rzVxsj0wZeA21eo5riPWKQVunEOw9ZJ0wHnpEKzpEpuz3JuuEe9BVXuQl9B+A3rJOY7Pbm7Lvvvrs69Xz9eaLb59/k325+XyTrYMKPdlXTFcV+6EpxwXzDBUeocKjUyNP87nQ23olNbGbF2Us3ffkCFhc7BrS0PGPTDmWUH5E9JfufUh2SSwvH6nn7SJLb8+y22yerdezVfYW8TfkJ6zrJ6a8Fty7eOrXZlo8hRW+Eb/57HUCU66nHNvoS65XOHdiyrWMcz5S5ESKnP+LF6+3haUbk8Ngyh+02s5xhrW9zX2laZyJ/KHx2o88xFmP9KlaM21/k7kTwlng2OgrcvqKnFeFl7b3Y8wGFaPI4W8sh+sdyglblIM0EcmJWpSDvK7zohzuWbSxqRzkdZVvR8lt7q+X7j05Di64R0cQHN7LcNwMSS/EjQDH6zMGXI9wJ4DTfCmg9aHiJ2vPj8CX6QRio/dVS/eeHAcLrj0I2vmI/RuTXohD37N/0ffsX/T9oX2+0DX176kp+7dH/ESHpmcsof/ejZ5zJOF+EGW9TvHzmBj5A/gynYAWIyHx0846yEPucYSXdt+27/zT9rkima5X55vp3dFncZ5OL9eHnCvEDu28zvs/ftf2kIjof3KjxO6AfLV8rL0EWt4MauwLa+wLFfueVtj3mxst7c8N5J2acv0ICIc+6hBO2x+Fh8RUtMcGWQvMOwtLNybHQRqRPr+40dr1r3uWHJXzNtc5C13AtXmWtXoEwU4P1PXef3nRryPAhQo934OMFXqtxk1MeY+MiJd2VsQ1vSFdxYc9hR75cRz/6kbrm3eDon6YU0PSHW0fEE7rmbW+PQadf3fPns+ZB+91AeEwD/ns17RPRR8waHud+OLQvY57IMRp97BaHeqSPMxb4f8y8hZ/Z+W8xRwNFXrO2315fp1vx4kpryXHN+ZMTDiU2yccrvsNycN4kbXBnKm6L9TOlHben8AP1xH3D5zLe6DQ/w26/OWeT025nnF8aXWJdTFGr3tV52aOR481ZKbVkIBke+p3Gt+TifyhKee7j3uyAenDMdQh/8Se1qauBmj3Vm+a7f8L8JqhfsJL64G1eOdaW9cParVWqyVcZ5rUEq3n0GrJyBzWK2t1gusI0v/jRot/QfajPK7LWkxptUDoY4Ue/RuRbMyJmHBVvydXxdagRq+6/UXTC2MP57LsfTZov5fXnSde4h4/1/Z4tJ33+Lpe2wKvwYlCr/XfE6JHn2t5yb0vyh0RDvOJc7aqL35Bduz7PUJ6B+13rx7wlR6g7fuI1fz82Wo2z5JNal+n++4jTkWnHOzKi3P67l3O6EyPv+EjfRTs7O1DbN3jFHmW7p0auqBivOehfOvmxW9xXqYP8zK9yB7mZR0FNwIc5oaFsXtHfyEv0SMi+ieOgazJAObI/Ikif0DyC3or3/g+eKTQjxR6uz5jN+nhzgNkt93X3Msk/viNdZPY8XHPd5dSi1W2SNPLWbqZpfN9efUfk3l1Bg0tAAA=","debug_symbols":"tZjRbiI7DIbfhWsuJo4Tx32VVVXRlq6QEK3Y9khHFe9+bOJ/phxpRt1Z7U3/j8J8JB4nAT43z/vHj58Ph9PL66/N3Y/PzeP5cDwefj4cX59274fXk/33czP4H0qbO9puiHrkHtyj9Kg9pEfrodfIJikWqQf1yD3MIhalR+0hPVoPvQYPPVIPs6TBMkdyZIk0UzI/myr561uk9iw+NBtbHSJTJEXmSI4skTVSIltk+MR92TJFUmSO5MgSWSMlskVqzxa+Fr4Wvha+5r5kWSJrpES2SO2pQ2SKpMgcGT4Nn7qPLSWyRWrPNAyABCBABjCgACpAAA0Ac4I5wZxgTjAnmBPMyc3Vwc3i0AAaQAPAzc2BABnAgAKoAAE0gAZ4q3dwszoQwF6TrTOTN3JODglAgAxggL17Jgd7r5wdNKAMgAQgQAYwoABsFtkLVQTQABrgi6JDAhDAzcWBAQVQAQJoAA3w5dHBhX6bfGF0YEABVIAAGkADfH10SACYG8y+RrLfbl8kHSpAAA2gAb5SOqC8ivIqyqtRXvJVkJuDP6UODCiACpDeCeQ93yF6g7znOyQAATKAAQVQATAnmBPMBDPBTDB7q18H763O1/80gMaYvbE7JAABbGCcHBhQADYwvh4ZAmgAmBlmhplhZhSTUUxGMRnF9A2+QwPAfF0XerlsNzjSHt7P+72faF/OODv53nbn/el9c3f6OB63m392x4/ri3697U7XfN+d7Vmrx/70bGnCl8Nx73TZTlcP85fyMNS4modMo6DcGtK8wXbMHAbbD/NosAX5bYU1ORRWyFlFnleUoqhC0fJFMciNgucVVTUMkursGL5bS5a5WtY/r2X981q2b9WyNuLZWuq8QmpCLaVNAqFVtazzfbnYVVzGYsowO4pEC/MojTGROkzVrHqrWOhMyQ33VJhoVsFLM8lSx6nwoLOSxanINBUaZhULvVWEsMbaNIbM314hdsaHgIapEpnK7RAWelN0vKmiOq0Qau3WsdCcWdDenKfuptvOooVp2EmFQZAdMrOKheYsLCgltzWCOg6hLoxgaRI5oS/txKyrFMKoJEmZL2X5qwr7MIfGtmVOqxSiuB32ca2uUmget27lWcXS4hjGUth3Dl1jsE/V045Hqwxt3GhoWDUGJmz96et29xuGwuMsiqRVBh3vRU15jSFPdzOXVbPIdTyHc1szCztwxv2aV1yv42cJlTX9qIQdRnnV+zeM/2ajXjP+/11/b492T4fzzQ9CFzedD7vH4z4evnycnr48+/7vG57BD0pv59en/fPHee+m6Vcl+/ODimxJ2r1/77eHhbZF/EHy50S31NL9xYfyHw==","names":["is_quest_completed"],"brillig_names":["is_quest_completed"]},{"name":"opt_in_leaderboard","hash":"2267029607426190283","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZjRbuM4DEX/Jc99kEhKlOZXBoNBpk0HAYK0yLQLLIr++5IRr5MsYKPjoi+9J7V9LNOU7ORt87D79fr75/74+PRn8+372+bXaX847H//PDzdb1/2T0f779sm+R/Km2/5bkM0gkfIiDKijtARbUQ/B6cRZmELGsEjZEQZUUfoiDain0PMUi3yCBrBI3wsdgopkT4astTIFtlHlhSZIymSIyWyRIavhK+Er4Svhq+Gr7pPLd3XLCWyRNZIjWyRfaSmyBxJkeHT8Gn4NHwaPg2fmo+sds0raeNqfWRPkTmSIjlSIktkjdTI8HX3mT+nBMgAAjBAAAVQAQpoAJgzzBnmDHN2c3YQQAFUgAIaoAdQAmQAAWAmmL3NWRwqQAEN0AO84QdkAAEYIACYGWaGmWFmmAVmgVlgFpgFZp8NXB3crA4KaIAe4FOCm0MGEIABAiiAClBAA/QAnxzcHTLA9iEfoff7GbzhB2QAARgggAKws1NxsLOTX0VL8Z+WAQIogBbQsY+3/wAG4KiOo3wKnE/RcS6fBA7kjT2gAGJn8l4dwADs7O03IAOwM8HsHXUGxs5+uyU5mFDOy7AACqACFGBCIV+s7VzCDgRggAAKoAIU0AA2MBFf9hMgAwjAAAEUgJuLgwIaoAd4SwzIAAIwwIXVoQIU0AA9wHtjQAYQgAECgLnB3Nzst8D7Z0AP8OV0QAYQgAEob0d5O8rbo7zsS6U0B9/UHRTQAD3AF0bvBPaFcQABGCCAAqgABTRADyCYCWaCmWAmmAlmXw/Pg/fuLf4fX/0GUIzZV78BAigAG1jxtwRf/QY0gA2skL8rJEAGwCwwC8wCs6CYgmIKiikopq9+AzIA5vO86O/vdxu8GP18Oe12/l509aZk70/P29Pu+LL5dnw9HO42/2wPr+ed/jxvj+d82Z5sq9Vjd3ywNOHj/rBzer+7HJ3mD1VtGkc3e7BNAnuyflRhfVRCYX3Dk6LcDoLmDfbQ5jDka0Ou/GGFLcFQ2Ko1q5B5RSkdhayN5KoUeqMoC9WsOQxW14tAaVUtOc/VUhcKIQljsOe4zg6izSta8if86IlULtdR+42hL9Sh+TN5FKL1NGfIaemGylQKewejOidZqiYl9JWtMjpXzY8aiswZMi9eyOU6NM3ekLzQmlqaoJ41ldl6LrUmN1yJCtGsoi5dCWudLkVSX3VLap0KetUZf3NLLgabLrO3pH9+jlD69CSh/OlZQvS1s+Sjq2/6/OpL5fPLL9UvXH/ty0cIKF3miE392yEsLJ7ap+muvV+qaa94t46F/mRFJYQvhaDbBueFy7D3fwyCiHlWsdCcRfBeUKStEdRpCHVhBEsXwRl9SXzV2X+jUEEl7b1+vpTlSxX23RSrtz0AaJVCO26HfQ2tqxSdp2neZVaxuFBMpbAfVfoag33dvzwLaZWhTY8gSqvGIHS1+K8aQ5HpKormVYY+3YuaeY2BL3fTvlesMtRpzea25irsVWR6KZEVx/fpudN1TT92wgrTZdX5G8Z/s1CvGf//jv9hn7b3+9PN797vbjrtt78Ou/j4+Hq8v9r68u8ztuB38+fT0/3u4fW0c9Plx3P7852t+nbffvgPm/ax5btW/UP2bY1sm/x496H8Bw==","names":["opt_in_leaderboard"],"brillig_names":["opt_in_leaderboard"]},{"name":"opt_out_leaderboard","hash":"10365352625226286239","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"profile_id","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1azY7jRBBux3ZiJzMkzArOPAGyM/mZuUXaWYYbBw6cTZJBHNCi1cLZEhInDhy5c+ExQELiJTjwFishIZGe6dp8+Vx2khk3y2q3pFHbrur666rq6s4EZguBGyN6NwrNwo3ZwyBvkVemKtoEQvO+e0jdewfwYYvGpiS3Tf4X2eQyVexrUf/z1PH06R/h6YF/1nN8Pi63/NkWC6fuHWNI5iSbvxOzfT5zzynN8bG2Hn2fPVL074BtFh6XXmSfC/8r4G9atE34P/Gj/0v+Hzn+PnS/9qN7PjB3cZzBWuPat2jLTHjjBtOiLVPJ29hUQXBdkN0hXA9wmAcMIb2jTdaXM+DLdKwP1rou0Yp+MdFakFgLSH6kzLdwVe7yEroPQO/v3LOtb++55+Lbrz75evl0tf70+dNnxRfrz559+XxtCDqkODtIlO0YHTwG3fxt0FX1aQo6oT8k6MSWSJlv4arc5SX0H4LeryzobOWT6hqVu3wW7nv2AJhfZJk4Iyy3jggVXSLAI/3UvffBThmjB+h5My/ym/PippgWq9VkWZwRf/Qb7xAcRDjPc7JNtAQJa3wjfvPYUeZcfUUf9g8nfazoOjLVQsIJFytyYkXOf8WL19vCwo3ZcTDmD1ph5TjDwtpmUT80zkR+31TX1UecdUmfujXTNheZOyKcBY6NniKnp8h5XXhhjJ6aaswGNaPI4W8sh+sdyglblIM0McmJW5SDvOTUxM1MG3KQ11V5N0pu49q1mEsXYkdiqiA4vKnhuOmTXogbAI7X5wRwXcKdAk7zpYDWBIqfrD3fA1+mE/B5U7GBOdceBPa95t+U9EIc+p79i75n/6Lv8QaFQfOv0B3q36Gp+rdL/O7bOH/jRs85knE/iLLepPi5T4z8BnyZTkCLkZD4hSSTY0RuhITXITeZSGftbftckY1Xy9l6vDn6zGf5+HJ1zLlC7OiSLugTiQn8ru0hMdH/4EaJ3YR8tbivvQRa3iQN9oUN9oWKfY9r7PvFjZb2xwPkDU21fgSEQx91CKftj8JDYireY4OsBeadhYUbs4dBHpM+P7nR2vW3e5YclfM21zkLEeDaPMtaPf4BPVDXW/+Vu34dAC5U6DH/cc9Deq3GjUx1j4yJl3ZWxDW9Jl3Fh12FHvlxHP/sRuubR8GufphTfdIdbU8Ip/XMWt+egs6/umfP58yj97qAcJiHfPY7tE9t+rlX2+vEF8fuddwDIa6n2KHVoYjkYd4K/1eRt/jLK+ct5mio0HPe7svzJ+XdODLVteT4xpxJCYdye4TDdb8meRgvsjaYM3X3hdqZ0s77HfjhOuL+gXN5DxT6P0GXP9zz0FTrGceXVpdYF2P0uld3buZ49FhDJloNCUi2p37n4Hsykd831Xz3cU+WkD4cQx3yT+ppbZpqgHZv9e7m7x1TXTPUT3hpPbAW71xrm/pBrdZqtYTrzCG1ROs5tFoyMMf1ylqd4DqC9H+50eJfkP3aD3VNMaXVAqFPFXr0b0yyMSdSwmk9QFNsJQ16Ne0vml4YeziXZe+zgXO+Tsb/YI+fans82s57fFOvbYHX4FSh1/rvEdGjz7W85N4X5Q4Ih/nEOVvXF78gO/b9HiG9g/a7Vxf4Sg/Q9n3Ecjr7fDmZFtk6t6/jffcRQ9GpBLvK3Tk99y5ndKbH/9pA+iDY2hsGW7/c0iryLN1ZA11QM97yUL5F5e63tKzSh2WVXmT3y6qOghsADnPDwol7R38hL9EjJvqhYyBrksAcmT9S5Cckf0dv5RvfBw8U+oFCb9cncZNe3nmA7Lb7mluZxB+/sW4SOz7u+TYpNV8W8zy/nOTrST7dl1f/AuDhj3JnLAAA","debug_symbols":"tZjRbuI6EIbfJddc2J4Zj91XWVUVbekKCdGKhSMdVbz78eD5Axwp0W62ven/hZAPZzK2KZ/D6+b59PNpu397/zU8/Pgcng/b3W7782n3/rI+bt/37dXPIdifWIeHtBpS6BF7pB7Ug3tIj9xDe5ThQVrUS1DoEXs0Swwtmya29xJ7imf2VM/iWXty8Iye5mteJk/2FE8bWfs8sYG2Y8me6lk8a88cPKNn8iRP9nRfNl9uqZ7Fs/bU4Bk9kyd5sqd4uk/dp+5T9xXzccvomTzJkz3FM3uqZ/GsPav7qvuq+bQlebKneGZP9SyetWcMARABCUAABgggAxRQADBHmCPM0czVoJkpGDBAABnQzBQNCqA6WKN3iIAEIAADBJABZk4GxcG6mcjA3sMGCiiA6mAt3cE+XQzss7KBADJAAQVQHSQAIsDuwgolBGCAADJAAQVg5tLAJkWHCEgAAjBAABlgQntMNikuYLOiQwQkAAEYIIAMUADMCrPND7bHbROkQwIQgAECyACUt6C8BeWtKK9NAbbnbj3Pl3UyACIgAah3QrKe7yCADFBAAVQH6/kOEZAAMEeYI8wR5ghzhNla3QafrNX58goDxMdsjd1BAQVgt8y2CwRABNgt27JvS3sHBsBMMBPMBDOhmIxiMorJKKYt8h0YADNfhOfzasB29nQ8bDa2m93sb23X+1gfNvvj8LA/7Xar4Z/17nR506+P9f6Sx/WhnW29sNm/tmzCt+1uY3ReXa8O05cSVfGriRONArk3xGlDWw3JDW2tuxraZPttRWtgKFqRJhU0rRCpqEIuia+KoHcKnlZojm5QLVeBpkW15DhVyzxTCA4YQ+Skk4PQaUUJNu0vihLkeh+53hnKTB2KrU29EKWGKUOde55cZOwJSXnKMVdMljIWs6TJxvyKzvyC1oxf0JvxW5vzpp4SwmQ9v6A749+3Z/z7/ozf3KDtu4gb2v45Xk9J7gRppre0MgahtV77M5Vy70gzj1XRWkzXzkr3DzXNNGfbWjGI1DbDScVMbwqrG4TLEkEeh5BnRjB3ExQx09vOnhcplFHJpDJdyvKtivbtk9GXetNWf6LQisfRvlbmRYpK48JZeVIxNznCWIr2v1FdYmjf/scZqmmRoeRx6Q6LxsDpZsFbNAbh8S5E4yJDHZ9FjrTEQNenSbLoLiiPmyCVJXehGe2gmRdcX8edvOqSfqwJK0zlRZ9fMP67hXrJ+P93/WM7Wr9sD3c/bJ3NdNiun3cbP3w77V9uzh7//cAZ/DD2cXh/2byeDhszXX8da39+JKFVW5we7feJdshlJWQH0c6ptHP6eLah/Ac=","names":["opt_out_leaderboard"],"brillig_names":["opt_out_leaderboard"]},{"name":"public_dispatch","hash":"12597578496141305004","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15353289549725070351":{"error_kind":"string","string":"Quest already completed"},"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"sync_notes","hash":"4541672825111826944","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"nZPdioMwEIXfZa69MJo/fZVSStRYAiFKqguL+O47KclWF7KU3mQyzpzPo5lsMOhuvd+MG6cHtJcNOm+sNfebnXq1mMnh0w3KsJAa2roAQqFlGBi0AgOHttn3AlL/bfFah/YDALGz8tot0LrV2gK+lF2fTY9ZuWdclMdqWYB2A0YEjsbqsNuLl7rMS0lJiYxy3Avxi8DsBCF5iJA8IiSKEkCQk77K61nFop6x1zcQyt81IGuRDLAmZ4Dm9bRuop5y+ZEBSZOBRuYM8Lyel+kP8Ip/YqCpqghoapYzIP8xINMQifLPEVwxVb3xp9neA8ob1Vkd03F1/aG6fM+pku7G7KdeD6vXgXS4ILhecAir+rqHt/0A","names":["sync_notes"],"brillig_names":["sync_notes"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"AztlanQuestPoints::_record_quest_completion_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::_record_quest_completion_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}},{"name":"quest_id","type":{"kind":"field"}},{"name":"points_earned","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanQuestPoints::complete_quest_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::complete_quest_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}},{"name":"quest_id","type":{"kind":"field"}},{"name":"points_earned","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanQuestPoints::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::constructor_parameters","fields":[{"name":"profile_registry","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"social_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"AztlanQuestPoints::create_quest_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::create_quest_parameters","fields":[{"name":"_quest_id","type":{"kind":"field"}},{"name":"_quest_data","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanQuestPoints::get_public_points_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::get_public_points_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanQuestPoints::get_quest_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::get_quest_count_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanQuestPoints::is_on_leaderboard_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::is_on_leaderboard_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"AztlanQuestPoints::is_quest_completed_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::is_quest_completed_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}},{"name":"quest_id","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"AztlanQuestPoints::opt_in_leaderboard_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::opt_in_leaderboard_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanQuestPoints::opt_out_leaderboard_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanQuestPoints::opt_out_leaderboard_parameters","fields":[{"name":"profile_id","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"AztlanQuestPoints"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"profile_registry","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"social_verifier","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"total_points_commitment","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"quest_completion_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"quest_completed","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"is_on_leaderboard","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"public_points","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}}]}}]}]}},"file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n// CONTRACT 3: PRIVATE QUEST POINTS\n#[aztec]\npub contract AztlanQuestPoints {\n    use dep::aztec::macros::{functions::{public, private}, storage::storage};\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable, FunctionSelector};\n\n    #[storage]\n    struct Storage<Context> {\n        // Contract references\n        profile_registry: PublicMutable<AztecAddress, Context>,\n        social_verifier: PublicMutable<AztecAddress, Context>,\n        \n        // Points data (stored as commitments)\n        total_points_commitment: Map<Field, PublicMutable<Field, Context>, Context>,\n        quest_completion_count: Map<Field, PublicMutable<Field, Context>, Context>,\n        \n        // Quest tracking\n        quest_completed: Map<Field, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        \n        // Leaderboard (optional public data)\n        is_on_leaderboard: Map<Field, PublicMutable<bool, Context>, Context>,\n        public_points: Map<Field, PublicMutable<Field, Context>, Context>,\n        \n        // Admin\n        admin: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[public]\n    fn constructor(\n        profile_registry: AztecAddress,\n        social_verifier: AztecAddress,\n        admin: AztecAddress\n    ) {\n        storage.profile_registry.write(profile_registry);\n        storage.social_verifier.write(social_verifier);\n        storage.admin.write(admin);\n    }\n\n    #[private]\n    fn complete_quest(\n        profile_id: Field,\n        quest_id: Field,\n        points_earned: Field\n    ) {\n        // Private function to complete quest\n        // In production: verify quest completion proof\n        \n        context.call_public_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"_record_quest_completion(Field,Field,Field)\"),\n            [profile_id, quest_id, points_earned]\n        );\n    }\n\n    #[public]\n    fn _record_quest_completion(\n        profile_id: Field,\n        quest_id: Field,\n        points_earned: Field\n    ) {\n        // Check not already completed\n        let already_completed = storage.quest_completed\n            .at(profile_id)\n            .at(quest_id)\n            .read();\n        assert(!already_completed, \"Quest already completed\");\n        \n        // Mark as completed\n        storage.quest_completed\n            .at(profile_id)\n            .at(quest_id)\n            .write(true);\n        \n        // Update quest count\n        let current_count = storage.quest_completion_count.at(profile_id).read();\n        storage.quest_completion_count.at(profile_id).write(current_count + 1);\n        \n        // Update points commitment (in production: use homomorphic addition)\n        let current_commitment = storage.total_points_commitment.at(profile_id).read();\n        let new_commitment = current_commitment + points_earned; // Simplified\n        storage.total_points_commitment.at(profile_id).write(new_commitment);\n    }\n\n    #[public]\n    fn opt_in_leaderboard(profile_id: Field) {\n        // User chooses to make their points public\n        storage.is_on_leaderboard.at(profile_id).write(true);\n        \n        // Reveal points publicly\n        let points = storage.total_points_commitment.at(profile_id).read();\n        storage.public_points.at(profile_id).write(points);\n    }\n\n    #[public]\n    fn opt_out_leaderboard(profile_id: Field) {\n        storage.is_on_leaderboard.at(profile_id).write(false);\n        storage.public_points.at(profile_id).write(0);\n    }\n\n    // ADMIN FUNCTIONS\n    \n    #[public]\n    fn create_quest(\n        _quest_id: Field,\n        _quest_data: Field  // Hash of quest details\n    ) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        \n        // In production: store quest details\n        // For now, just emit event or store in mapping\n    }\n\n    // VIEW FUNCTIONS\n    \n    #[public]\n    fn is_quest_completed(profile_id: Field, quest_id: Field) -> bool {\n        storage.quest_completed.at(profile_id).at(quest_id).read()\n    }\n\n    #[public]\n    fn get_quest_count(profile_id: Field) -> Field {\n        storage.quest_completion_count.at(profile_id).read()\n    }\n\n    #[public]\n    fn get_public_points(profile_id: Field) -> Field {\n        if storage.is_on_leaderboard.at(profile_id).read() {\n            storage.public_points.at(profile_id).read()\n        } else {\n            0  // Private by default\n        }\n    }\n\n    #[public]\n    fn is_on_leaderboard(profile_id: Field) -> bool {\n        storage.is_on_leaderboard.at(profile_id).read()\n    }\n}\n","path":"/root/x/aztlan/contracts/aztlan_profile/src/main.nr"},"68":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"69":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"71":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/hash.nr"},"97":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"104":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"145":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"146":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"147":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"163":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"172":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"288":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"305":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"325":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"343":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"344":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"363":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}