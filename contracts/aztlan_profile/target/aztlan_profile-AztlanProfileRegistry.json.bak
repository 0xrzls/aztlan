{"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"AztlanProfileRegistry","functions":[{"name":"constructor","hash":"8389724663315169708","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1WPW/CMBB1EgdwAxJq1f/hFFAYM7SVOnXo0NnNR9WhokKoMz+9jXRWjldDh9gSA09C9nGXd/fOh0kkekS0SrCFI6akVQ9D7pFLOws9BRvzRKuiNWb+xKNYBXl98q/1cqUc+jzWv1DEGbI/ljMAvx4Tz/2+50ctHWZk8xmyz0x+P1PR72e0V/BMiLMN2Ht946jf5spIawn9iVl/oiOrEIfnaRFD3zCm9KRrLv4/58SjDsl8pWcNPL8EDalHDSP/Gu7mUCfPEzCv6X6rt8Rlvj+fv6pN3bzsNlvz3rxuP3aNAOBQj8COHHEceBF4FPOGjfJ8CRR2mMYOXdY3Yblj8Cmoi/uumC8FX8Z8EfimzHfqzSQBm/epq/mR8WKcRcCzqwJeEPllLvo94sznog43F3lzmYt+j/AxFxnTIPfiQEtJ3+sBKNZa23wJ8afib+08fwrxD2TzftpVDqizLUzeLkxrVqaul5W5Bv4Ox14gB/8pS7BTRxxHV8AP6r4rVesOAAA=","debug_symbols":"pdTNjoIwFIbhe+maRU//TuutGGNQqyEhaBAmmRjufQqfMLKAGN3wiMgrnCZ9iFM8tJd9UZ2vd7HZPsShLsqyuOzL6zFvimuVvn0I2R/IiA1lgixwgIEHYUBJQEABDVBRqKhUcQkGqcKJMKAlIKCABgZY4AADVHSq+EwYCQgooIEBFjjAwANULCo2VUJCAQ0MsMABBh6EAScBKg4V7qekuy4T48j3TR1jP/GXNUgrc8vrWDViU7VlmYmfvGyHH91veTXY5HW6KjMRq1MyBc9FGftPXfZ/t1y+ldnz825PxFOApHk3QY7cM0FO2ylh5w+hVgpG0lgw6uUhWM0SejnhpR4fwkvrp4QLs4JZmYTX4VlgH+RSwa68Bhlvx/cgq9xSY3WYVk3D9HJpmKuFoMcCK/VJgfX0Gsz6k8KbC0ry6xUl+npJSX26prt0lh+LerZzdn2tLvJDGZ+n57Y6vlxtfm/jlXHnvdXXYzy1dexLL9tvOm6dyVzYdf2//QE=","names":["constructor"],"brillig_names":["constructor"]},{"name":"create_profile","hash":"16596814893246232917","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"},{"name":"token_uri_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6759731346603734577":{"error_kind":"string","string":"Profile exists"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15865011268275408360":{"error_kind":"string","string":"Username taken"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["create_profile"],"brillig_names":["create_profile"]},{"name":"get_address_by_username","hash":"10835371586846186384","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzYobRxDu2dFIGmkVKU4eZGZXWu3eBF5vcgvETzCRtIGE4CQkuQXmmEseIwGDX8IHv4XBYPDB+OKbwQZj9arL++mbmpEWdfunQPRMV3VVdf11TSsya4jcz0IL5hhkbubGbD/IPfLKIkXPxk1oC966MXXjAeBjjxtPFV188T/Nxmepqe7Zo/7HqeMZ0j7CMwD/rOP4fFNe8+e9WBiYzeTANV2Hl+dbsMbCt8Bb1oe028rvp4Htln9l6m0lMXe7DCL7WPifA3/jj38m/O+E0f89/4sw/PO+Wcfh0uix5tNWA7Ppe/SHyMWDxOM+x1r9jmkO5fdM2JyISJ7ow/YRP4jtEkXXkYLDXEMcykkUOR+KF/vbwsyN2c3giCcGik4cZ22Y9+jXya5xJvJ7io1CxFmb9Knzmdiuo+g6UnAcGx1FTkeR8znxkhgdmGrMRjWjyOE5lsP1DuXEHuUgTUJyEo9ykJeciSKn7VEO8jov16PkNvp15sZsP3jfW3ZBN495eiY24h4c7dcD2RyTfdILcYeAY98PANcm3BeAw3xgiOkd7WTHn4Ev0wmkihyP9j0dkF4IbHvNvj3SC3Foe7Yv2p7ti7bX8kBAs6/YaVf7DhU5bZIvPFs0L3BerseE6O+6MXCOZLeAryFZqbI/j7KnfC4iDJR9c/ykpBfiMLY4fjC20F8MWowIndXrf+DLdAJajMTET+tXkYd8pwyV9a0a/RKFls9ved81NoV+7kZrgyfu2ebk1+65+OuX736d31ss7/5x7/fix+X3y2IR1ejJdme6uIbO+lD83yo36WduPtsDpqfXF1lxeW0HjgmUnxD9T+4dY1HG1h56Xk6L/PK4uCwmxWIxnhecwxYOwE74LSox1CZd5LmuZmm9Ades39z4MWuWtr+4YX+xsr/bNfv7142W9s8d5A1N9fyNCIc2OiCcdnYKD4mpZMsexBdY8yzM3JjtB3lC+vztRruvp+5Z6qPkBdokZA6vYGz1eAZ6oK5X9is37doHXKzQcw09VOi182VE9HguRfSOvNCnF6Sr2LCt0CM/juN/3Ght84b0w5zqEQ733iWc9i2kfY+loPN/7jnw/cGN+4yIcJiH/E2/aw/b9GeO1meILW7aZ3D/iTjtW16rQy2Sh3kr/D9G3uJ3HOct5mis0HPebsvzO+V6HJmqLzm+MWdSwqHcDuHQ7xckD+NFfIM5w+e6du8ge7Dr7gM/9COeH7iWz0Chfwi6PHDPQ1OtZxxfWl1iXYzR617T3SfGY8AaMtZqSESyA/U7O99/ivyeqeZ7iPvPLunDMcT30mkg3zTVAO0+8kuzvodhn6F+wkvrgbV451rb1A9qtVarJVxndqklWs+h1ZK+uVmvrNUJriNI/8iNFv+Y9o/yuC5rMaXVAqFPFXq0b0KyMSdSwmk9QFNsdRv0ajpfNL0w9nAty962B875OhmfwBk/0c543Duf8U29tgX2wUCh1/rvEdGjzbW85N4X5fYJh/nEOVvXFz+mfWz7n0l6B+3/zDbwlR7A931EdrSYnyyPVlcm05P86Gyx7T7Ct/z55OSH+XhSZMv8Sptt8odik/Iaj/FvoePe5Y6A6YVfQvTPhXb1e+GeJa4SRZ6le91AF9WMVzyUuVa5OZeWVfq4rNKL7F5Z1VFwfcBhblo4dO9oL+QleiRE/8q9i0+6sEbWjxT5XZK/obcyhznKvGJlTuitf14KPzfi3n33VVcyiT/OsW4SOyHyapVS03kxzfOzcb4c55NtefUO7hwjrsUoAAA=","debug_symbols":"tZfdauMwEIXfxde5kEbSjNRXWUpJ23QJhLRkk4Wl5N13JqNjNws21LA3PZ/t6ot+xrL9Obzuni8/n/bHt/dfw8OPz+H5tD8c9j+fDu8v2/P+/ahnP4dgf2IbHmQzUPCIHuSRPLJH8WAP8agebkluSWqpGuSRPLJH8WAP8age7RY5eLgluyW7Jbslq4U12EM8qke7RQke0YM8kkf2cEtxS1FL06ge7RYcPKIHeSSP7FE82MMt7BZ2i7hF3CJuEbeIW8Qt4hZxi6glRk3VRNoMNfSMPamnqmLSzD1LT+4pPWvP5tlCz9iTepova+ae5tOFbdxTetae6iPtRwx6gpKBndGWMQZABBAgAfRnqBiol9igAloHK1CHCCBAAmSA9pfEgAECqIDWwYrWIQLMXA0SIAMKgAECqIDWwSqYmgEBEiADCoABAqiA1sFq2gHmArNVdgoGGVAADBBABbQOjOllTC9jehnTa8WctBqjFXCy5bYSdsiAAuBeCVbKDqgNq+YbWDk7RAABEiADCgDmCnOFucLcYG4wW0nfOm81nW5nBFB7n62MDSgEQATYkLNBAmSADbkYMEAAFc1hjjBHmCMBEiADCoABAoCZbsLrdTNgb386n3Y729q/bPb6CPjYnnbH8/BwvBwOm+H39nC5/dOvj+3xluftSa9qLeyOr5oqfNsfdkbXzdQ6zDctnNG6sEyCcm+I84YYOHWDbhdpNGgJ3iloQVG4G3TJRkGicidI8wJpuXSDtDb1gWq9U+R5RRLMQ055EtxPQ5lvT7rwGASlNGfghaXIgpXIdUV7HjvA87+/NIIUsZCUiNcYZCwmkjI7izH8V0XkmlGQ8qWevqOQhrXQbY5XKVoab4uW5xULBt0iYaBcZm+suLAipTRMJ1eapjMGuXcs1JVwxL0lU13q82TVHtPm95i6NBfjDa7vG2G2F7EtjKOMdSEcpvnkdr9PLYxEUsWiSiaaVSyuahIeh5JDm5Ms1VYYJ1Rf3tpcbS0Z9I1jmk9aZajjMCis6kMmFFb8OpnfMJQ8jqJIXGVo413KMa0xpOk+T2XVKBKP93mqa0ah5TwWdl7Rvo1P8Ca8pj3h5mx51e9X9P/u4b2m//+0f9Sj7cv+dPcNfTXTab99Puz64dvl+PLl6vnPB67gG/zj9P6ye72cdmaaPsT1zw/SV3kq4dE+oPQwhrjRdyI7jHa1RL2aHq/Wmb8=","names":["get_address_by_username"],"brillig_names":["get_address_by_username"]},{"name":"get_admin","hash":"7663402563339616079","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUTQuCQBDdLaM282JB/YwVFT166B7ULxj86BRGRGd/egqz7LikBK4Plpl11jdvnh+caXCMDuuDsz/AR66dMAqMC1JftivDvZyGQBh9bfKnMorFj/ks6g8FcvJ5+KXin8l/uUaec6P56Syq76ZdO5J7mHsj98+pvX22kSCctvlbBPsB/R1c9ME3ZqXflCUd0Pl+QC74PC7PvC7K27t+wb28llDQnqZeZtRozgfOeWz4PXCZ/ic4Td+XzMK8SSql6rtE/hXTvlM4pE7PH3G/JfpVdCborBIIqhAqiKEoohx8g58ZPn0BsvgMZ6kFAAA=","debug_symbols":"fdJNroMgEADgu7BmwT/WqzSNQcWGhKCh8JIXw90LjVpZ2A0jzswHBFYw6j4+O+Om+QXa+wp6b6w1z87OgwpmdvnvClAZMAMthwDzHFKCYK/ogte6FJxaMrQor10ArYvWQvCnbPwUvRblPjEon7MIAu3GHDM4GavLV4LfbnTdKiQVW7eQnB0ArwV8LWDM+CZgLL9bwJJUBLkmJG/YRkiB+EGIWyXQHwJt6C4wQq4E9usYVIrjHAzdKuORZ2owvrrRVDRvVG/1Np2iG07Z8L/smf1FLH4e9Bi9LtLpWeTxjhtI6COV1d4=","names":["get_admin"],"brillig_names":["get_admin"]},{"name":"get_next_profile_id","hash":"3920486896653916182","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUXQuCMBTdyqhlvlhQP2Oioo8+9B7ULxhOewojomd/ehPu2HWkBM4D495557nnHj8oMaAQPdIHJX+Ajlw7QWQQF6i+VKuAPZ+GiFl9XfLnPEnZj/kc6o8ZcNJ5+Lnmn8l/vgaec2v48Sy670atHcoDyIOR++fUrp5twhCna36FaD+gv4MPPoTWrPibcqSj7Hw/AJf4PC7PspHV7d28xL26VkLinrZeYtVwTgfOBWT4PfCJ+Sd4bd+XwsG8Wc657rsE/hUxvmN4qI7PH2G/Rfp19CborDMR1bGoRSqkTEoRWvzE8ukLprYui6kFAAA=","debug_symbols":"fdLdCoMgFADgd/Hai/yvXmWMsLIhiIXTwQjffTqq5UW78WTnnE9FVzCqPjw6baf5CdrbCnqnjdGPzsyD9Hq26e8KqjwgCloGAWIpxAjBXtF5p1QuOLUkaJFOWQ9aG4yB4CVN+BY9F2m/0UuXshUEyo4pJnDSRuWvCH/d1XUr56TZujnn4gBYKaBrASHKNgEh8dsCErgg8DUhWE03QvCKHQRvCoH8EUhNdoFifCXQf8cggh/noFVTGPc0k4N2xY3GrDkte6O26RTscMr697Jn9hexuHlQY3AqS6dnkcYbqiEm95hX+wA=","names":["get_next_profile_id"],"brillig_names":["get_next_profile_id"]},{"name":"get_profile_id","hash":"14917370256558997959","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzYobRxDu2dFIGmkVKU4eZEYrrXZvAq83uQXiJ5hI2kBCcBKS3AJzzCWPkUAgL5FD3sJgMPhgfPHNYIOxetXl/fRNzUiLuv1TIHqmq7qquv66phWZDUTuZ6EFcwwyN3djdhjkHnllkaJn4ya0Ba/dmLrxCPCxx42nii6++J9lk/PUVPfsUf+T1PEMaR/hGYB/1nF8vihv+PNeLAzMdnLgmq7Dy/MdWGPhS+At60Pabe33s8B2yz8z9baSmLtbBpF9IvwvgL/xxz8T/vfC6P+W/2UY/nnfbOJwZfRY82mrgdn2PfpD5OJB4nGfE61+xzSH8nsmbE5EJE/0YfuIH8R2iaLrSMFhriEO5SSKnHfFi/1tYe7G7HYw5omBohPHWRvmPfp1um+cifyeYqMQcdYmfep8JrbrKLqOFBzHRkeR01HkfEy8JEYHphqzUc0ocniO5XC9QzmxRzlIk5CcxKMc5CVnoshpe5SDvC7KzSi5jX6duzE7DMbCuwu6eczTc7ER9+Bovx7I5pjsk16IOwYc+34AuDbhPgEc5gNDTO9oJzt+D3yZTiBV5Hi079mA9EJg22v27ZFeiEPbs33R9mxftL2WBwKafcVO+9p3qMhpk3zh2aJ5gYtyMyZEf9+NgXMkuwN8DclKlf15lD3jcxFhoOyb4yclvRCHscXxg7GF/mLQYkTorF5/A1+mE9BiJCZ+Wr+KPOQ7Zaisb9Xolyi0fH7L+76xKfQLN1obPHLPNic/d8/Fbz989ePiwXJ1/5cHPxffrr5eFcuoRk+2O9PFNXTWh+L/VrlNP3fz2QEwO7u5yIrLGztwTKD8hOi/c+8YizK2DtDzalbkVyfFVTEtlsvJouActnAEdsJvUYmhNukiz3U1S+sNuGb95Mb3WbO0/cUN+4uV/d2t2d+fbrS0v+4hb2iq529EOLTREeG0s1N4SEwlO/YgvsCaZ2HuxuwwyBPS53c32n09ds9SHyUv0CYhc3gNE6vHE9ADdb22X7lt1z7gYoWea+ixQq+dLyOix3MponfkhT69JF3Fhm2FHvlxHP/hRmubV6Qf5lSPcLj3LuG0byHteywFnf9yz4HvD27dZ0SEwzzkb/p9e9imP3O0PkNscds+g/tPxGnf8lodapE8zFvh/z7yFr/jOG8xR2OFnvN2V57fKzfjyFR9yfGNOZMSDuV2CId+vyR5GC/iG8wZPte1ewfZg133D/BDP+L5gWv5DBT6/0CXf93z0FTrGceXVpdYF2P0utd094nxGLCGTLQaEpHsQP3O3vefIr9nqvke4v6zS/pwDPG9dBrIN001QLuP/NRs7mHYZ6if8NJ6YC3eudY29YNardVqCdeZfWqJ1nNotaRvbtcra3WC6wjS/+9Gi39I+0d5XJe1mNJqgdCnCj3aNyHZmBMp4bQeoCm2ug16NZ0vml4Ye7iWZe/aA+d8nYwP4Iyfamc87p3P+KZe2wL7YKDQa/33iOjR5lpecu+LcvuEw3zinK3rix/SPnb9zyS9g/Z/Zhv4Sg/g+z4iGy8Xp6vx+spkdpqPz5e77iN8y19MT79ZTKZFtsqvtdklfyg2KW/wGP8WOu5d7giYXvglRP9UaNe/Z+5Z4ipR5Fm6lw10Uc14zUOZa5Xbc2lZpY/LKr3I7pVVHQXXBxzmpoVj9472Ql6iR0L0L9y7+KQLa2T9SJHfJflbeitzmKPMK1bmhN7657nwcyPu3XdfdS2T+OMc6yaxEyKv1ik1WxSzPD+f5KtJPt2VV28AVfjodMUoAAA=","debug_symbols":"tZfdaus6EIXfxde5kGYkjdRX2ZSStukmENKSnRw4lLz7mcloOfEBG2rYN11f4uqLfkay/T28714vv1/2x4/PP8PTr+/h9bQ/HPa/Xw6fb9vz/vOo334Pwf7ENjzJZqDgET3Igz2SR/YoHuJRPdzCbmG1VA3yYI/kkT2Kh3hUj3aLFDzcktyS3JLcktRSNIqHeFSPdoscPKIHebBH8nBLdktWS9OoHu0WJXhED/Jgj+SRPYqHW4pbilvELeIWcYu4RdwibhG3iFtELTFqqibSZqihZ+xJPVUVWTP1zD1LT+lZezbPFnrGntTTfEkz9TSfLmwrPaVn7ak+0n7EoF8QG9g32jLGAIgAAjBAf4aygXqpGFRA62AF6hABBGBAAmh/SQwKQAAV0DpY0TpEgJmrAQMSIAMKQAAV0DpYBVMzIAADEiADCkAAFdA6WE07wJxhtsrmYJAAGVAAAqiA1qFgegumt2B6C6bXipm1GqMVMNtyWwk7JEAGlF4JVsoOqA2r5htYOTtEAAEYkAAZAHOFucJcYW4wN5itpG+dt5rm2zcCqL3PVsYGFAIgAmzIyYABCWBDzgYFIICK5jBHmCPMkQAMSIAMKAABwEw34fW6GXC2v5xPu50d7Q+Hvd4Cvran3fE8PB0vh8Nm+Gd7uNz+6c/X9njL8/akV7UWdsd3TRV+7A87o+vm3jrMN805UG+dM5VRkKeGOG+IoXA36HHBo0FLcKKgBUUu3aBLNgqY8kTA8wJpKXeDtHbvA9U6UaR5BQtmMXG6C6bTkOfbky48BkHMc4aysBRJsBKprmhfxg6U+d9fGgFHLCTxQyn8wCAJk0iSZ2cxhr+qiKUmFKQ81NNPFNKwFnrMlVWKxuO2aGlesWDQIxIGSnl2Y8W8tL0bprNUuk9nDDJ1LNSVlIi9Jfe61PvJqjOGZfaMqUtzMW5wfd4Is72IbWEceawLKeE+n6VNz6mFkQhXLKokolnF4qqylHEoKbQ5yVJthXGT6MNbm6utJYM+cdznk1YZ6jgMCqv6kAiFFR8n8weGnMZRZImrDG3cpSXyGgPf9znnVaPgMu5zrmtGoeU8FnZa0b6Nd/AmZU17wuZsadXvV/R/cvNe0///tX/WT9u3/WnyDn0102m/fT3s+sePy/Ht4er53y9cwTv41+nzbfd+Oe3MdH8R1z+/SB/lKYdne4HSjzHEjT4T2cdoV3PUq/x8tc78Bw==","names":["get_profile_id"],"brillig_names":["get_profile_id"]},{"name":"get_quest_points_contract","hash":"7639044522515731702","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUyw6CMBBsBaMVuaCJfkYJEPDGwbuJfkHDw5PBGOOZT7ck23RphJhQJml2y5bZ2eFBiQaF6JI+KPkDdOTaESKDuEB1R64c9nwaQmb0tcmf8ThhP+azqD9iwEnn4eeKfyb/+Qp4zq3mx7Oovmu5tij3IfdH7p9Tu3y2MUOctvklwt2A/g4e+BAYs+JvypKOU+f7HrjE53F5Fk1Z3d7NS9yrayVK3NPUS4wazunAOZ8Mvwce0f8Et+37kluYN804V30d4F8S7TuGi+r4/AH2G6RfRXeCzjoVYR2JWiSiLONCBAY/MXz6AlQD6F6pBQAA","debug_symbols":"fdJNroMgEADgu7BmwT/WqzSNQcWGhKCh8JIXw90LjVhd2A0jzswHBFYw6j4+O+Om+QXa+wp6b6w1z87OgwpmdvnvClAZMAMthwDzHFKCoFZ0wWtdCg4tGVqU1y6A1kVrIfhTNn6KXotynxiUz1kEgXZjjhmcjNXlK8FvN7puFYzyrVswcdsBfhbwtYAxqwLG8rsFLMmJINeE5A3bCCkQ34m8n6NAfwi0oVVghFwJ7NcxqBT7ORi6nYxHnqnB+NONpqJ5o3qrt+kU3XDIhv+lZuqLWPw86DF6XaTDs8jjHTeQ0Ecqq70B","names":["get_quest_points_contract"],"brillig_names":["get_quest_points_contract"]},{"name":"get_social_verifier_contract","hash":"9680649760377289028","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUXQuCMBTdyqhlvlhQP2Oioo8+9B7ULxhOewojomd/ehPu2HWkBM4D495557nnHj8oMaAQPdIHJX+Ajlw7QWQQF6i+VKuAPZ+GiFl9XfLnPEnZj/kc6o8ZcNJ5+Lnmn8l/vgaec2v48Sy670atHcoDyIOR++fUrp5twhCna36FaD+gv4MPPoTWrPibcqQj73w/AJf4PC7PspHV7d28xL26VkLinrZeYtVwTgfOBWT4PfCJ+Sd4bd+XwsG8Wc657rsE/hUxvmN4qI7PH2G/Rfp19CborDMR1bGoRSqkTEoRWvzE8ukLXiT5KKkFAAA=","debug_symbols":"fdJNroMgEADgu7BmwT/WqzSNQcWGhKCh8JIXw90LjVZZ2A0jzsxHJrCCUffx2Rk3zS/Q3lfQe2OteXZ2HlQws8t/V4DKghloOQSY55ASBHtFF7zWpeDUkqFFee0CaF20FoI/ZeOn6LUo94lB+ZxFEGg35pjByVhdvhI8utF1q6CYbt2C8gPgtYCvBYwZ3wSM5SFgSSqCXBOSN2wjpED8S4hbJdAfAm32MSQj5Epgv8agUnznYOhWGY+8U4Px1Y2monmjequ37RTdcMqG/2XP7C9i8fOgx+h1kU7PIq933EBCH6mc9gY=","names":["get_social_verifier_contract"],"brillig_names":["get_social_verifier_contract"]},{"name":"get_token_uri","hash":"17384235642802127617","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzYobRxDu2dFIGmkVKU4eZGZXWu3eBF5vcgvETzCRtIGE4CQkuQXmmEseIwGDX8IHv4XBYPDB+OKbwQZj9arL++mbmpEWdfunQPRMV3VVdf11TSsya4jcz0IL5hhkbubGbD/IPfLKIkXPxk1oC966MXXjAeBjjxtPFV188T/Nxmepqe7Zo/7HqeMZ0j7CMwD/rOP4fFNe8+e9WBiYzeTANV2Hl+dbsMbCt8Bb1oe028rvp4Htln9l6m0lMXe7DCL7WPifA3/jj38m/O+E0f89/4sw/PO+Wcfh0uix5tNWA7Ppe/SHyMWDxOM+x1r9jmkO5fdM2JyISJ7ow/YRP4jtEkXXkYLDXEMcykkUOR+KF/vbwsyN2c3giCcGik4cZ22Y9+jXya5xJvJ7io1CxFmb9Knzmdiuo+g6UnAcGx1FTkeR8znxkhgdmGrMRjWjyOE5lsP1DuXEHuUgTUJyEo9ykJeciSKn7VEO8jov16PkNvp15sZsP3jfu3ZBN495eiY24h4c7dcD2RyTfdILcYeAY98PANcm3BeAw3xgiOkd7WTHn4Ev0wmkihyP9j0dkF4IbHvNvj3SC3Foe7Yv2p7ti7bX8kBAs6/YaVf7DhU5bZIvPFs0L3BerseE6O+6MXCOZLeAryFZqbI/j7KnfC4iDJR9c/ykpBfiMLY4fjC20F8MWowIndXrf+DLdAJajMTET+tXkYd8pwyV9a0a/RKFls9ved81NoV+7kZrgyfu2ebk1+65+OuX736d31ss7/5x7/fix+X3y2IR1ejJdme6uIbO+lD83yo36WduPtsDpqfXF1lxeW0HjgmUnxD9T+4dY1HG1h56Xk6L/PK4uCwmxWIxnhecwxYOwE74LSox1CZd5LmuZmm9Ades39z4MWuWtr+4YX+xsr/bNfv7142W9s8d5A1N9fyNCIc2OiCcdnYKD4mpZMsexBdY8yzM3JjtB3lC+vztRruvp+5Z6qPkBdokZA6vYGz1eAZ6oK5X9is37doHXKzQcw09VOi182VE9HguRfSOvNCnF6Sr2LCt0CM/juN/3Ght84b0w5zqEQ733iWc9i2kfY+loPN/7jnw/cGN+4yIcJiH/E2/aw/b9GeO1meILW7aZ3D/iTjtW16rQy2Sh3kr/D9G3uJ3HOct5mis0HPebsvzO+V6HJmqLzm+MWdSwqHcDuHQ7xckD+NFfIM5w+e6du8ge7Dr7gM/9COeH7iWz0Chfwi6PHDPQ1OtZxxfWl1iXYzR617T3SfGY8AaMtZqSESyA/U7O99/ivyeqeZ7iPvPLunDMcT30mkg3zTVAO0+8kuzvodhn6F+wkvrgbV451rb1A9qtVarJVxndqklWs+h1ZK+uVmvrNUJriNI/8iNFv+Y9o/yuC5rMaXVAqFPFXq0b0KyMSdSwmk9QFNsdRv0ajpfNL0w9nAty962B875OhmfwBk/0c543Duf8U29tgX2wUCh1/rvEdGjzbW85N4X5fYJh/nEOVvXFz+mfWz7n0l6B+3/zDbwlR7A931EdrSYnyyPVlcm05P86Gyx7T7Ct/z55OSH+XhSZMv8Sptt8odik/Iaj/FvoePe5Y6A6YVfQvTPhXb1e+GeJa4SRZ6le91AF9WMVzyUuVa5OZeWVfq4rNKL7F5Z1VFwfcBhblo4dO9oL+QleiRE/8q9i0+6sEbWjxT5XZK/obcyhznKvGJlTuitf14KPzfi3n33VVcyiT/OsW4SOyHyapVS03kxzfOzcb4c55NtefUOPKRRPcUoAAA=","debug_symbols":"tZfdauM8EIbvxcc50Ix+RuqtLKWkbboEQlqyyQcfJfe+Mxm9Trxgwxr2pO+TuHqin5Fsfw/vu9fLz5f98ePz1/D043t4Pe0Ph/3Pl8Pn2/a8/zzqt99DsD/UhifZDBw8yIM9okfyyB7FQzyqh1uiW6JaqgZ7RI/kkT2Kh3hUj3aLFDzcktyS3JLcktRSNIqHeFSPdoscPMiDPaJH8nBLdktWS9OoHu0WJXiQB3tEj+SRPYqHW4pbilvELeIWcYu4RdwibhG3iFtELUSaqiHeDDX0pJ7cU1UUNVPP3LP0lJ61Z/NsoSf15J7mS5qpp/l0YVvpKT1rT/Wx9oOCfsHRwL7RlkQBQAAGRID+DGcD9XIxqIDWwQrUgQAMiIAE0P6yGBSAACqgdbCidSCAmatBBCRABhSAACqgdbAK5mbAgAhIgAwoAAFUQOtgNe0Ac4bZKjsGgwTIgAIQQAW0DgXTWzC9BdNbML1WzFGrkayAoy23lbBDAmRA6ZVgpeyA2rBqvoGVswMBGBABCZABMFeYK8wV5gZzg9lK+tZ5q+l4+0YAtffZytiAQwAQwIacDCIgAWzI2aAABFDRHGaCmWAmBkRAAmRAAQgAZr4Jr9fNgLP95Xza7exofzjs9RbwtT3tjufh6Xg5HDbDf9vD5fZPv762x1uetye9qrWwO75rqvBjf9gZXTf31mG+aRZJvXWWlkZBnhpo3kChxG7Q4yKOBi3BiYIXFLl0gy7ZKIicJ4I4L9Ce526Q1u594FonijSviIJZTPE+DTydhjzfnnXhMQiOcc5QFpYiCVYi1RXty9iBMv/7SyOIhIXkyGWNQRImkSXPziKFf6qgUlHSJA/19DcKaVgLPebKKkWL47ZoaV6xYNAjEgZOeXZj0cKK5NwwnaXyfTopyNSxUFdSCHtL7nWp95M1Z0wNefaMqUtzMW5wfd4Is72gtjCOPNaFlIdulDY9pxZGIrFiUSUxzyoWVzVKGYeSQpuTLNVWGDeJPry1udpaMugTx30+eZWhjsPgsKoPiVFY9DiZf2HIaRxFFlplaOMuLRTXGOJ9n8e8ahSxjPs81jWj0HIeCzutaN/GO3iTsqY9Y3O2tOr3K/o/uXmv6f8f7Z/10/Ztf5q8Q1/NdNpvXw+7/vHjcnx7uHr+/wtX8A7+dfp8271fTjsz3V/E9c8P1kd5zuHZXqD0IwXa6DORfSS7mkmvxuerdeY3","names":["get_token_uri"],"brillig_names":["get_token_uri"]},{"name":"get_total_profiles","hash":"815268377957369190","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUyw6CMBBsBaMVuaCJfkYJEDhy8G6iX1B5eDIYYzzz6ZZkmy6NEBPKJM1u2TI7Ozwo0aAQXdIHJX+Ajlw7QmQQF6juyJXDnk9DyIy+NvkzHifsx3wW9UcMOOk8/Fzxz+Q/XwHPqdX8eBbVdy3XFuU+5P7I/XNql882ZojTNr9EuBvQ38EDHwJjVvxNWdJx63zfA5f4PM7Poimr67t5iXt1qUSJe5p6iVHDOR0455Ph98Aj+p/gtn1fcgvzphnnqq8D/EuifcdwUR2fP8B+g/Sr6E7QWacirCNRi0SUZVyIwOAnhk9frJE//akFAAA=","debug_symbols":"fdJNroMgEADgu7BmIf/WqzSNQcWGhKCh8JIXw90LjVhZ2A0jzswHBDYwqSE8e23n5QW6+wYGp43Rz94so/R6senvBpo8IAo6BgFiKcQIQanovVMqF5xaErRKp6wHnQ3GQPAnTfgUvVZpP9FLl7INBMpOKSZw1kblrwi/3c11K2e0dHPGxQGwWkDXAkKU7QJC4rsFJHBF4GtCsJbuhOANOwh+qwTyQyAtKQLF+Eqgv45BBD/OQZtbZTzSTI7aVTcas+a0HIzap3Ow4ynr/9eSKS9idcuopuBUlk7PIo131EJMHjGv9gY=","names":["get_total_profiles"],"brillig_names":["get_total_profiles"]},{"name":"get_username_change_cooldown","hash":"11916587404666847618","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUXQuCMBTdyqhlvlhQP2Oioo8+9B7ULxhOewojomd/ehPu2HWkBM4D495557nnHj8oMaAQPdIHJX+Ajlw7QWQQF6i+VKuAPZ+GiFl9XfLnPEnZj/kc6o8ZcNJ5+Lnmn8l/vgaec2v48Sy670atHcoDyIOR++fUrp5twhCna36FaD+gv4MPPoTWrPibcqRDdr4fgEt8Hpdn2cjq9m5e4l5dKyFxT1svsWo4pwPnAjL8HvjE/BO8tu9L4WDeLOdc910C/4oY3zE8VMfnj7DfIv06ehN01pmI6ljUIhVSJqUILX5i+fQF0UUoEqkFAAA=","debug_symbols":"fdJNroMgEADgu7BmIf/UqzSNQcWGhKCh8JIXw90LjVhd2A0jzswHBFYw6j4+O+Om+QXa+wp6b6w1z87OgwpmdvnvCpoyIApaBgFiOaQEQa3ogte6FBxaMrQor10ArYvWQvCnbPwUvRblPjEon7MNBNqNOWZwMlaXrwS/3c11K5eEbd1cCrwD7CygawEhWgWExHcLKGtHAl8Tgkm6EYI3bCf47SSQHwKRpAoU4yuB/joGEXw/B21uJ+ORZ2ow/nSjqWjeqN7qbTpFNxyy4X+pmfoiFj8PeoxeF+nwLPJ4RxJi8khltTc=","names":["get_username_change_cooldown"],"brillig_names":["get_username_change_cooldown"]},{"name":"get_username_change_count","hash":"15980641557286412790","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzYobRxDu2dFIGmkVKU4eZGZXWu3eBF5vcgvETzCRtIGE4CQkuQXmmEseIwGDX8IHv4XBYPDB+OKbwQZj9arL++mbmpEWdfunQPRMV3VVdf11TSsya4jcz0IL5hhkbubGbD/IPfLKIkXPxk1oC966MXXjAeBjjxtPFV188T/Nxmepqe7Zo/7HqeMZ0j7CMwD/rOP4fFNe8+e9WBiYzeTANV2Hl+dbsMbCt8Bb1oe028rvp4Htln9l6m0lMXe7DCL7WPifA3/jj38m/O+E0f89/4sw/PO+Wcfh0uix5tNWA7Ppe/SHyMWDxOM+x1r9jmkO5fdM2JyISJ7ow/YRP4jtEkXXkYLDXEMcykkUOR+KF/vbwsyN2c3giCcGik4cZ22Y9+jXya5xJvJ7io1CxFmb9Knzmdiuo+g6UnAcGx1FTkeR8znxkhgdmGrMRjWjyOE5lsP1DuXEHuUgTUJyEo9ykJeciSKn7VEO8jov16PkNvp15sZsP5gK7y7o5jFPz8RG3IOj/Xogm2OyT3oh7hBw7PsB4NqE+wJwmA8MMb2jnez4M/BlOoFUkePRvqcD0guBba/Zt0d6IQ5tz/ZF27N90fZaHgho9hU77WrfoSKnTfKFZ4vmBc7L9ZgQ/V03Bs6R7BbwNSQrVfbnUfaUz0WEgbJvjp+U9EIcxhbHD8YW+otBixGhs3r9D3yZTkCLkZj4af0q8pDvlKGyvlWjX6LQ8vkt77vGptDP3Wht8MQ925z82j0Xf/3y3a/ze4vl3T/u/V78uPx+WSyiGj3Z7kwX19BZH4r/W+Um/czNZ3vA9PT6Iisur+3AMYHyE6L/yb1jLMrY2kPPy2mRXx4Xl8WkWCzG84Jz2MIB2Am/RSWG2qSLPNfVLK034Jr1mxs/Zs3S9hc37C9W9ne7Zn//utHS/rmDvKGpnr8R4dBGB4TTzk7hITGVbNmD+AJrnoWZG7P9IE9In7/daPf11D1LfZS8QJuEzOEVjK0ez0AP1PXKfuWmXfuAixV6rqGHCr12voyIHs+liN6RF/r0gnQVG7YVeuTHcfyPG61t3pB+mFM9wuHeu4TTvoW077EUdP7PPQe+P7hxnxERDvOQv+l37WGb/szR+gyxxU37DO4/Ead9y2t1qEXyMG+F/8fIW/yO47zFHI0Ves7bbXl+p1yPI1P1Jcc35kxKOJTbIRz6/YLkYbyIbzBn+FzX7h1kD3bdfeCHfsTzA9fyGSj0D0GXB+55aKr1jONLq0usizF63Wu6+8R4DFhDxloNiUh2oH5n5/tPkd8z1XwPcf/ZJX04hvheOg3km6YaoN1HfmnW9zDsM9RPeGk9sBbvXGub+kGt1mq1hOvMLrVE6zm0WtI3N+uVtTrBdQTpH7nR4h/T/lEe12UtprRaIPSpQo/2TUg25kRKOK0HaIqtboNeTeeLphfGHq5l2dv2wDlfJ+MTOOMn2hmPe+czvqnXtsA+GCj0Wv89Inq0uZaX3Pui3D7hMJ84Z+v64se0j23/M0nvoP2f2Qa+0gP4vo/Ijhbzk+XR6spkepIfnS223Uf4lj+fnPwwH0+KbJlfabNN/lBsUl7jMf4tdNy73BEwvfBLiP650K5+L9yzxFWiyLN0rxvooprxiocy1yo359KySh+XVXqR3SurOgquDzjMTQuH7h3thbxEj4ToX7l38UkX1sj6kSK/S/I39FbmMEeZV6zMCb31z0vh50bcu+++6kom8cc51k1iJ0RerVJqOi+meX42zpfjfLItr94B2dPFwMUoAAA=","debug_symbols":"tZfdauMwEIXfxde5kEbSjNRXWUpJ23QJhLRkk4Wl5N13JqPj1As21LA3PV/i6ot+RrL9Obzuni8/n/bHt/dfw8OPz+H5tD8c9j+fDu8v2/P+/ajffg7B/sQ2PMhmoOARPcgjeWSP4sEe4lE93JLcktRSNcgjeWSP4sEe4lE92i1y8HBLdkt2S3ZLVgtrsId4VI92ixI8ogd5JI/s4ZbilqKWplE92i04eEQP8kge2aN4sIdb2C3sFnGLuEXcIm4Rt4hbxC3iFlFLjJqqibQZaugZe1JPVcWkmXuWntxTetaezbOFnrEn9TRf1sw9zacL27in9Kw91Ufajxj0C0oG9o22jDEAIoAACaA/Q8VAvcQGFdA6WIE6RAABEiADtL8kBgwQQAW0Dla0DhFg5mqQABlQAAwQQAW0DlbB1AwIkAAZUAAMEEAFtA5W0w4wF5itslMwyIACYIAAKqB1YEwvY3oZ08uYXivmpNUYrYCTLbeVsEMGFAD3SrBSdkBtWDXfwMrZIQIIkAAZUAAwV5grzBXmBnOD2Ur61nmr6XT7RgC199nK2IBCAESADTkbJEAG2JCLAQMEUNEc5ghzhDkSIAEyoAAYIACY6Sa8XjcDzvan82m3s6P9y2Gvt4CP7Wl3PA8Px8vhsBl+bw+X2z/9+tgeb3nenvSq1sLu+Kqpwrf9YWd03dxbh/mmrKvXW7OOYRSUqSHOG2Lg1A16XKTRoCU4UdCConA36JKNgkRlIkjzAmm5dIO0du8D1TpR5HlFEsxiTvdpoOk0lPn2pAuPQVBKcwaeN5QsXVByXdGexw7w/O8vjSBFLCQl4jUGyZhEkjI7izH8V0XkmlGQ8qWevqOQhrXQY45XKVoat0XL84oFgx6RMFAusxsrLqxIKQ3TyZXu0xmDTB0LdSUcsbfkXpd6P1l1xlCZPWPq0lyMG1yfN8JsL2JbGEcZ60I43LvBbXpOLYxEUsWiSiaaVSyuahIeh5JDm5Ms1VYYN4k+vLW52loy6BPHfT5plaGOw6Cwqg+ZUFjx62R+w1DyOIoicZWhjbuUY1pjSPd9nsqqUSQe93mqa0ah5TwWdl7Rvo138Ca8pj1hc7a86vcr+j+5ea/p/z/tH/XT9mV/mrxDX8102m+fD7v+8e1yfPly9fznA1fwDv5xen/ZvV5OOzPdX8T1zw/SR3kq4dFeoPRjDHGjz0T2MdrVEvVqerxaZ/4C","names":["get_username_change_count"],"brillig_names":["get_username_change_count"]},{"name":"has_profile","hash":"12596977937560402860","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzY7jRBBuj+MkTiYkLDyIPeNMZm6RdnbghsQ+gUkycFkWoRXi6DsXHgMkJF6CA2+xEhISB8SF20q72nTStfPlc9nJKN37U1LUdld1fdXVVdXtTmS2FLmfpQ70MUnf3LXZcZR71JVFip2tk9AGRO4hde8nwI89TjxVbPGl/zIrrlJTn7NH+89TpzOkf0RnAP1Zz+n5rLrTz3OxNDK7yYFj+o4vzw9gjKXPQbeMD+m39bpfBvZb/olp9pXE3MMqCPa56L8G/caf/kz0Pwpj/xv9N2H050OzjcNvjB5rPn01Mrtrj+shuLiReJxnodXvmPoQf2DC5kREeGIP+0fWQXyXKLZOFB7mGvIQJ1Fw3pYuXm9Lc9dm96Mz7hgpNnGcdaHf47pOD40zwR8oPgoRZ12yp2nNxHc9xdaJwuPY6Ck4PQXnQ9IlMToy9ZiNGlrB4T7G4XqHOLFHHJRJCCfxiIO6ZE8UnK5HHNR1XW1byW1c17lrs+OoEN19sM1jnl6Jj/gMjv4bADbH5JDsQt4p8HjtR8DrEu8j4GE+MMX0jn6y7begl+WEUgXHo38vR2QXEvte8++A7EIe+p79i75n/6LvtTwQ0vwrfjrUv2MFp0v4orND/ULX1bZNSP6xawPnSPYA9BrCSpX5ecSe8b6INFLmzfGTkl3Iw9ji+MHYwvVi0mJE5Kxdv4JelhPSYiQmfdp5FXXId8pYGd9psC9RZHn/lvdDY1PkF661PvjLPduc/NQ9lz88+eK7xdPl6vGzp9+XX6++XJXLqMFO9jvLxQ1ysdF9ibKxqc87VnTguBPSYWNF4qxT7eqZu/7sCJpd3l2YxU5/Yuqxh/gJyT9x7xjz0naOsPN2Vua35+VtOS2Xy2JRcq0w4C/+5pVY7ZIt8txUG7UzCNfGZ659l7VRm1/cMr9Ymd/Dhvn97For++MBeGMajzE9Vnx0QjxtjxYdElPJnjnIWmBttTR3bXYc5QnZ42A38/rbPUsdlrxAn4TM4TUV1o5/wA60deO/atevQ+DFijzX6lNFXtvHJiSP+19E76gL1/SGbBUfdhV51Mdx/JNrrW9ekX2YUwPi4dz7xNO+ubTvvhRs/sU9B76nuPd5JiIe5iHfHRx6Vm7700g7z4gv7nue4XMu8rQ7A60OdQgP81b0v4u8xe9FzlvM0ViR57zdl+ePqm07MfW15PjGnEmJh7g94uG63xAexousDeYM7+va/YbMwY77DfThOuL+gWN5DxT5P8CW393z2NTrGceXVpfYFmP0utd2x4rxGLCGFFoNiQg70Hnn4HtWwR+Yer6HuGftkz0cQ3z/nQZam7YaoN17fmy29z28Zmif6NLOwFq8c61tOw9qtVarJVxnDqkl2plDqyVDc7+zslYnuI6g/J+utfznNH/E47qsxZRWC0Q+VeTRvwlhY06kxNPOAG2x1W+xq21/0ezC2MOxjL1vDpzzTRjvwR4/1fZ4nDvv8W1nbUu8BiNFXjt/T0gefa7lJZ99EXdIPMwnztmmc/Fzmse+/7Pk7KD9b9oFvXIG8H0fkZ0tFxers/WVyewiP7ta7ruP8I2/mF58tSimZbbKN9bswx+LT6o7Psa/pZ57lzsClhd9Ccn/K7Lr33/uWeIqUfCs3MsWuaih3ehQ+jrVbl9a1eXjqi4v2IOqbqPwhsDD3LR06t7RX6hL7EhI/oV7lzXpwxgZP1Hw+4S/Y7fSV7s/VOSHirxdn/9Fn2tx7r7PVRtM0o99bJvEToi8WqfUbFHO8vyqyFdFPt2XV68BrsLsui0pAAA=","debug_symbols":"tZjdbuM4DIXfxde5EKkfSn2VQVGkbToIEKRFJllgUeTdlwx17GQBGzMG5qbnS1J/kURKdvs9vO9eLz9f9sePz1/D04/v4fW0Pxz2P18On2/b8/7zqO9+D8F+UBueZDNw8CAP9ogeySN7FA/xqB5uiW6Jaqka7BE9kkf2KB7iUT3aLVLwcEtyS3JLcktSS9EoHuJRPdotcvAgD/aIHsnDLdktWS1No3q0W5TgQR7sET2SR/YoHm4pbiluEbeIW8Qt4hZxi7hF3CJuEbUQaaqGeDPU0JN6ck9VUdRMPXPP0lN61p7Ns4We1JN7mi9ppp7m08K20lN61p7qYx0HBRVyMiAAdyB7JxvYO8UgAhIgAwpAv4n1G8galKsBARgQAQmQAQUgAB0yN4PWwZrWgQAMiIAEUHMMBgUggApoHayRHQjAABVGMsiAAhBABbQO1tMOBGBABMCcYbb+jlYd63CHCmgdrM8dCMAALG/B8hYsb8HyWkvHaGBfauW2RnYQQAW03gnWzg7oDWtohwhIgAwoAAFUAMwN5gZzg7nB3GC2rr4N3to6ZjsMA4B8zGxt7BABCWBTLgYFIACb8u10bR0oAGAmmAlmgpkyoAAEUAGtg20QB5j5JrxeNwOO/ZfzabezU//uPqB3h6/taXc8D0/Hy+GwGf7ZHi63X/r1tT3e8rw96afatrvju6YKP/aHndF1M10d5i/NtZZ+dW6hjoL8aKB5A4USu0FPkjgatDsfFLygyBiDVnMURM4PgjgvkJZyN0hr0xi41gdFmldEwSomrcwoeFyGPH+9FhdD0PLGOUNZKEUSVCLVFdeXcQBl/vuXZhAJheTIZY1BEhaRJc+uIoW/qqBSExpS7vrpTxTSUAs9AcsqRYvjtmhpXrFg0NMTBk55dmPRQkWybmo0ReVpOSnIo2Ohr6QQ9pZMfak3llVnDLXZM6YurcW4wfXBI8yOgtrCPPLYF1LCtJ6lPZ5TCzORWFFUScyzisWqRinjVFJoc5Llqcg0FQ6z41g4MrMwalKnMcQUf7eqFMadSuFOwb9979GHyjQVlVcZxs7Sx9BVY0iM7qb7iv6BIadxFllolaGNR0WhuMYQp8Mm5lWziGU8bGJdMwvdU2NLphXXt/ExoklZcz3jhGhp1fdXjP/hCWLN+P93/bO+2r7tTw9/41/NdNpvXw+7/vLjcny7+/T87xc+wf8Ivk6fb7v3y2lnpukfBfrjh96xN5zjs/1dpy91c24oNHtJ9qluNM7l+WqD+Q8=","names":["has_profile"],"brillig_names":["has_profile"]},{"name":"is_username_available","hash":"500179066516795251","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VZzY7jRBDujOMkTiYkLDyIPZNMZm6RdnbghsQ+gUkye2G1CBAc8ZkLjwESEi/BgbdYCQmJA+LCDQkk0pOunS9fPjsZxWZ3S4ra7qquqq6/LndabgOt8PPQhjkGm5uHMT0Oshp5pS2hZ+UmqhYk4fUEpqMaN54IXerif5lOrhK3u+ca9T9PAs8m7WM8G+CfdgOfD4p7/rwXD0O3nRy4phfw9vwI1nj4EHjb+ibttvb7ZcN2y95z5baymHtcNCL73PhfA39XH//U+D9pRv9X/G+a4Z8N3CYOnzkda3Xaaui2fY/+MLl4kNS4z4mq3xHNofy+azYnWiTP9GH7mB/MdrHQdSxwmGuIQzmxkPN/8WJ/e5iHMX0YnPHEUOjEcdaB+Rr9Oj00zkx+X9ioiTjrkD5lPjPbdYWuY4Hj2OgKOV0h523iZTE6dLsx2yoZTQ7PsRyudygnqlEO0sQkJ65RDvKyM9HkdGqUg7yui81ouY1+nYcxPQ5e9ZY90K3GPL0yG3EPjvbrg2yOyQHphbhTwLHvh4DrEO4dwGE+MET0jnby43Pgy3QGiZBTo30vh6QXAtte2bdPeiEObc/2RduzfdH2Kg8MlH3NTofadyTkdEi+8WzTvMF1sRljon8axoZzJH0EfB3JSsT+apQ943MRYSj2zfGTkF6Iw9ji+MHYQn8xqBgxOq/XD8CX6QxUjETET/WryMO+U0ZifbtEv1jQnpTIPTQ2jW4RRm+DX8Ozz8n3w3P+1fOPPlu8WK6efvni8/zZ6uNVvmyV6Ml2Z7qohI7xseDL/ZfygY8Fi6N2sY2fh/n0CJhd3l+IRcW9rhxbKD8m+k/DO8a0je0j9Lyd5dnteX6bT/PlcrLIuRY4sCF/01osdkgXey6rfarH4Nr3RRhfZ+1T+4sq9heJ/T0u2d93YfS0Xx8gb0TrMZZHwkYnhFNnsPGwmIr37MF8gbXTwzyM6XGQxaTPN2H0+/otPFudtbxAmzSZw2uYeD1+Bz1Q1zv7Fdt2HQAuEvRci08FvTqnxkSP51uL3pEX+vSGdDUbdgQ98uM4/jaM3jb/kn6YU33C4d57hFPfVOq7LgGdvw/PDd9DPLhfaREO85DPpkN74ao/hVS/YrZ4aL/CfSzi1J2AqkNtkod5a/xfR97i9yDnLeZoJOg5b/fl+ZNiM47dri85vjFnEsKh3C7h0O83JA/jxXyDOcPnurq/sD34dT8CP/Qjnh+4ls9Ao/8ZdPkpPI/cbj3j+FJ1iXVxTte9qjtUjMcGa8hE1ZAWyW6o3zn4HtXk991uvjdxj9ojfTiG+H47acg3VTVA3Wu+6zb3Oewz1M94qR5YxTvX2qp+UNVaVUu4zhxSS1TPoWrJwD2sV1Z1gusI0v8SRo9/SftHeVyXVUypWmD0iaBH+8YkG3MiIZzqAapiq1ehV9X5ovTC2MO1LHvfHjjny2S8AWf8VJ3xuHc+46t6bQ/sg6GgV/33mOjR5iovufdFuQPCYT5xzpb1xS9pH/v+r7LeQf0v2gG+1gPUfR+Rni0XF6uz9ZXJ7CI7u1ruu4+oW/5ievHJYjLN01V2p80++SOzSXGPx/j30A3vdkfA9MYvJvo/jHb9+zM8W1zFQp6n+6eCrlUy3vEQc+1iey4pdumjYpfeZPeLXR0NNwAc5qaH0/CO9kJepkdM9H+Hd/NJD9bY+rGQ3yP5W3qLOcxR5hWJOaP3/vnL+IUR9153X3Unk/jjHOtmsdNEXq1TarbIZ1l2NclWk2y6L6/+A2ve3tcNKQAA","debug_symbols":"tZjbTiM5EIbfpa9z4SofyuZVRggFCKNIUUCZZKUVyrtvVZf/TrJSt3Z6NTf8X2j8xYdyBfge3nevl58v++PH56/h6cf38HraHw77ny+Hz7ftef951O9+D8G+UBueZDNw8CAP9ogeySN7FA/xqB5uiW6Jaqka7BE9kkf2KB7iUT3aGCl4uCW5JbkluSWppWgUD/GoHm2MHDzIgz2iR/JwS3ZLVkvTqB5tjBI8yIM9okfyyB7Fwy3FLcUt4hZxi7hF3CJuEbeIW8QtohYiTdUQb4YaelJP7qkqipqpZ+5ZekrP2rN5ttCTenJP8yXN1NN8erCt9JSetaf6WOdBQYWsA4gMsoGquRgwIAISIAPUz2JgQj1nsrp0IAADIiABMqAAdKLcDCqgdbBadSAAAyJAzTEYZEABCKACWgerXwcCqDCSQQJkQAEIoAJaBytlBwIwAOYMsxV1tLOwsnYQQAW0DlbeDgTA9hZsb8H2Fmyv1XGMBvamdtxWvQ4FIIDaK8GKeISK2rAydmBABCRABhSAAGCuMDeYG8wN5gaz1fI4eSvmOH6nObBVr82ZAwEYEAG25GKQAQVgSx57aQW0DgQzwUwwE8yUABlQAAKogNaBYeZReL1uBjT5l/Npt7Mef9f19bPga3vaHc/D0/FyOGyGv7aHy/hDv762xzHP25M+1bLdHd81VfixP+yMrpvb6DA/tATrSePoEhJPgvxooHkDhRK7QRtInAxalA8KXlDk0g16iJMgcn4QxHmBtJS7QVq7zYFrfVCkeUUU7GLSk5kEj9uQ58ezlgIWwTHOGcq8ISfpgpzqivFlmkCZf/+lFUTCQXLkssYgCZvIkmd3kcIfVVCpCQUpd/X0OwppOAttfGWVosXpWrQ0r1gwaNOEgVOevVi0cCI5N2xnqXzbTgry6FioKymEuyW3uiThVT2mzPeYurQX0wUnPdTZWVBbWEee6kJKuO1naY99amElEisOVRLzrGLxVKOUaSkptDnJUm3pLw5tcmS5uyaPLZMXemabmm5rdBPIf/7ooDBdVQq1zVX48jrS7VR5laFOm8lh1RwSo7zp/kh/w5DTtIostMrQpl5RKK4xxFu3iXnVKmKZuk2sa1ahl2q6XmnF+Db9HtGkrBnPaBEtrXr/GqYLEf/f/P81/llfbd/2p4c/6a9mOu23r4ddf/lxOb7dPT3//YUn+JfA1+nzbfd+Oe3MdPu/gH75oZ/eG878bH/Y6UsKcaO30l6SPc1Rn+bnq03mHw==","names":["is_username_available"],"brillig_names":["is_username_available"]},{"name":"public_dispatch","hash":"16218347200742171856","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6759731346603734577":{"error_kind":"string","string":"Profile exists"},"12404158037908504363":{"error_kind":"string","string":"Not your username"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15371982489698173836":{"error_kind":"string","string":"Only admin"},"15865011268275408360":{"error_kind":"string","string":"Username taken"},"16481276443224907681":{"error_kind":"string","string":"New username taken"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"set_contracts","hash":"9137108446714366164","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"social_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"quest_points","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VVTU/DMAx111ZQOkDi48IFJP5ASltWbhzgjAQHzlGTIg4wVE2c99OhmqM5XrYdmliq7MjO8/Nr0kawsgifwRL0E9g0U/OIXoyzwiOWCMkzCsTTEjmC7WZyt+gztn/Ixx4Hzlhfn/iNqO4zx3we+ZcZwQyAf2fwkzD44gBxnpY2PrC+x2BfXrrH5OgZe8bcIeZNfIJxxvBCvHfKybdu5w7+pleOs17hevr/nGIsf79eftq50m/6W+meysml32X8WIC/0eRA92KD7mLeyw/9qqXinFMSA8vRONlSx/OpQ4uU5UztJfpB7huwtYnBuzbNlPTk2rz3nwsNzPh3N2bryFFHjd8Tj8M8jB6Gv+GJo45aDusfSrJc7/N1MWeNEIZTjPgp2KID65+y+mtcH5G5jE9G8OxmsuhK2claKlW18ozhU93yAP1VXVeVkEXVda0om3Zf/z8OY8PysgkAAA==","debug_symbols":"rZTNroMgEIXfhbULht/BV2maxlramBg1VG9y0/juF1qxuoBFezccAfmYOUzmQS72PN1OTXft76Q8PMjZNW3b3E5tX1dj03d+9UFoGECSkhcEFCnRi34JktJ4MU9h9CVAShBe2aLca1gXQee5IJF+Gp21Ab65zgcxVM52Iym7qW0L8lO10/On+1B1Tx0r53dpQWx38eqB16a14Wsu3qdp+igYoZfTYJRcAXJPgDRBIBcLQaBgK0GZHYGlCSg1WwgoUacI2SxMjIFRYKksRIYAQkYfQL+NBM12CJlGaIkxCK2oTKWhMgSOPBIES1qpc2lwrdY8BDUfmYkbM0XKzAyBUYErAVWyqHJBCAoxD8F08j0gU5lIefQCqcSUFZApTY3cxBdBQ5MInq0sfJeWZOqDJ2EAsTCYxyUNlf9gqPreUP29ofipoUc/q+rG7fr2HGiuqc6tXabXqas3u+PvEHdi3x9cX9vL5GwgbZq/Hw9MFRyOvtv7/n7grODiOIer/wA=","names":["set_contracts"],"brillig_names":["set_contracts"]},{"name":"set_username_change_cooldown","hash":"13444084030309150746","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_cooldown","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUTUvEMBBNv9BYF8EPvCj4E1Kasj168C7owfPQJOJBV8rieX+6BiYkjul62GSgTIZM3rz3GlIwHwXmmtQs0nOPWRwWXUIsESW6L1zPHWaOuQz2q4RiOZmbEn8UcuARfQn59xwxc/rjMDPgiyPEedh5fKrFxgrr8A65M8c/3ynz6xWuOTmT499m9F5cRPi7WS1qvcba6j/DNXy9P35OG6Wf9YfSc2gZpbsv6K9n6aSBpXv5h+52M8OrftKgKOel94/2VQt9dL+JeFGTPdfreFq7b4k3JUvujbLeXC148zK/bTUjURKRtC4ifWG0zL+z9c6fS3WX16MQjkOF+A37fbEYmd+Q/husTwJdLtcH8DRr6EwPBgZQSk5wTvBD39oM89UwSCmgk8ZMoh+n/+Z/A2Ir/HEdCAAA","debug_symbols":"nZTBjoMgEIbfhbMHBhgZfJWmaWxLGxOihuomm8Z3X7Cl1gMc9sIvAh8zP5N5sqs9z/dT19+GB2sOT3b2nXPd/eSGSzt1Qx/+PhmPAyjWyIoBsoaC1C/RrDFB6CVmFRH2gwoKUZelYol2mry1EfaFD5eOrbf9xJp+dq5iP62b102Pse1XnVofVnnFbH8NGoC3ztn4tVTbaZ4/ijzGs55GLsUHgHsC5AmKZCIoUhuhNjuCyBMItXgTCEnnCMUsavhkoU0uC5UnACh8EwD0ZiRosUNgHqGRkhG65phLoy4QJMlEUCJrpS6lIXX9yUNx8y8zcTOTIGdmiQCQzERAmS2qAiLEnoIAJXT2PaBQmcRl8oI4Us4KKJSmJmnSi5DhWYQsVhZtpYWi3kGOYdZeOr9rK0uk+a49O/ue3ub+8rU6/Y5pJbWl0Q8Xe529jaSv3hTGg5CVoGPoQhAnppJwXOLVfw==","names":["set_username_change_cooldown"],"brillig_names":["set_username_change_cooldown"]},{"name":"sync_notes","hash":"17597051922335559207","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"nZPdioMwEIXfZa69MJo/fZVSStRYAiFKqguL+O47KclWF7KU3mQyzpzPo5lsMOhuvd+MG6cHtJcNOm+sNfebnXq1mMnh0w3KsJAa2roAQqFlGBi0AgOHttn3AlL/bfFah/YDALGz8tot0LrV2gK+lF2fTY9ZuWdclMdqWYB2A0YEjsbqsNuLl7rMS0lJiYxy3Avxi8DsBCF5iJA8IiSKEkCQk77K61nFop6x1zcQyt81IGuRDLAmZ4Dm9bRuop5y+ZEBSZOBRuYM8Lyel+kP8Ip/YqCpqghoapYzIP8xINMQifLPEVwxVb3xp9neA8ob1Vkd03F1/aG6fM+pku7G7KdeD6vXgXS4ILhecAir+rqHt/0A","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"transfer_admin","hash":"16490429188928300325","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"15371982489698173836":{"error_kind":"string","string":"Only admin"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUTUvEMBBtt100rovg10XBv5DSlO1xD94FPXgemkQ86EpZPPena2CGxjHdPTQZKDOTTN68eSnJs9Fy9CXLs0DNFr2cZ1VELBkkesio5gG9QL/w9ouIwwrWNyZ+K1UjAvNF5F8LxEypD2EmwJcniPM4jPh8FmdrzP1/iM6c/n7n2RivMRbsTIq7Tai9vArwp14rnPUWczf/Bcbw/fH01e20eTGf2vS+ZJzuIeNXn8UbDRzd639097se3syzAc05T71/vK6YqKO1JcbLgBYl26Na4unkvsfY8b+Z4P/av+8Nb76YIEp5Hqjzzd03vSXl8Bdni+tyhm1aKYlDMYxCFAEupbfv199hfubNRb6cwdNuoLI1WGhAa9XBJcP3dVsl6K+bRikJlbK2k3XbHev/A4G9ckfBBwAA","debug_symbols":"nZTNjoMgFIXfhbULfuXiq0yahlrakBA0VCeZNL77QCtWJ4HFbDgi8ME9XO4TXc1lvp+tvw0P1H090SVY5+z97IZeT3bw8e8T4dQQjjrWICJQB1Hat0jUqSjwFvUSGucTviwNypTzFIxJkB02bjbqYPyEOj8716Bv7ebXpMeo/UsnHeIobpDx16gReLPOpK+l+azG5aWCtnm1oBI2gDgSSJnAgfGVwIHTjdCqA4GWCSAkXQkgQJYItSgYljkKRkUpCl4mEMLFSiBEfowkkh4QooyQArIRssWiFEZbITBgmcBp0UpZC4PJdouDY/UfM6namSlLZlavoyUbAXAxqSqIePaMIHx3iL/3QSqZCZhlLwALKFlBKqkpgal8I6BwEcGqmQWf1Irv7QA5xZ7ubTiUkyXRgtUXZ9bubfb9bnT6GfNILkdjGHpznYNJpF1Niu0XpQ2Vp1h9SOpAw/BpSVv/Ag==","names":["transfer_admin"],"brillig_names":["transfer_admin"]},{"name":"update_token_uri","hash":"5309316345957075995","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"new_uri_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"3532100565774060828":{"error_kind":"string","string":"No profile"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1aT2/jRBQf17ETJy3NsiAhgYTEiaPdOk1XAinSplBOSHDg7E1SxAEWVStOHHxGQuLEgRt3LnwMkJD4Ehz4FmTaeckvPz87Sethtdp9UjW235v3b95782bSwKwhcGOH3o1CM3Fjej/IWuSVqoo2gdC86x4S934A+LBFYxOS2yb/8zQvEsW+FvU/TRxPn/4Rnh74p13H55NyzZ9tsXDk3jGGZE5v+Xdo1s8P3XNCc3ysrUffpw8V/Q/ANguPSy+yT4X/FPibFm0T/hd+9F/x/8jx96H7x358s6pJl358kw3MbZ6MHT+bO8fuufju60+/nT2dLz5ffDNfXGO6cag3AZeNFt2TC+/IeHHPmZSaWLFLcF2Sjbjejv4K6R1tsjw+BL5Mx/pgf9AlWpETEa0FSY+A5HeU+Ram5SYvoX8P9P7BPduwesM9r8Pq2dPr4svFZ4tiHtToyb5iurpeKDR6XCBtqPCIFB5hg7yIaN53o7X9R/fsMf5PX8V/VZ+m+Bcddol/0amjzLcwLTd5Cf0I9Mb4f9M9c/x/cf3Vs4UhOCDFO/QeKHQItq7L3tEp1/PaCo7xeZquEqlcOyJUdOkAHuk/cO99sAvtndxRz6txkV2dFlfFqJjP81nxOvFHv/H+d2SqySrzElMNsBaTLQ8UPcMa34jfPPbjWWCqscdFEX0pvosUXYemWmDrNhyUEyly/i9evN4WJm5M94MT/nCkyOU4i+F7i+s62jXORH7feN1kVnEWkz51a6ZtPDJ3aKqFn2Ojq8jpKnJeFF4Yo7wJCl4bRQ5/YzlaA9hUJ+8qB2kikhO1KAd5XZSbcuIW5SCvaXk7Sm5z0zRx7+n94JwbLwTB4T0Xx02f9ELcAHC8PoeAiwl3BDjNlwJaEyh+svb8BHyZTsDnPc8Sxlx7ELSml/2bkF6IQ9+zf9H37F/0/b5NttDt6t9jU/VvTPxEh44ix8K0vB0jov/ejZ5zJOV+EGW9TPFzlxj5E/gynYAWIyHxC0kmx4jcdwmvXe6Bkc7a2/a5Ij2Zz84WJ8ujz/gsO3k033auaFv+aZbm58VsqcbiST7PZvuca8SPMeliTLX/wO/aHhYR/c9ulNzB+PWdt70G+8IG+0LFvsc19v3uRkv7yw7yjk21fgWE0y5GBKftz8JDYira0Qah/9WNVm7olJEclvM410ELnXLTvon7nt4PcqtHDHqgrjf6l5t2DwAXKvRYH3BPRHqtBg5NdQ+NiJd2lkSfX5Ku4sNYoUd+HGe/udH65p1gUz+M+T7pjrb3CKf11Fpfn4DOf7hnz+fQvffCgHCYJ3w23LWPbfoxXdsLxRf77oXcIyGuq9ih1YkOycO8Ff7PI2/xd23OW8zRUKHnvN2W5xfl7Tg01bXk+MacSQiHcruEw3W/JHkYL7I2mDN194namdPO+wv44Tpifce5XN+F/h/Q5W/3fGyq9YzjS6tLrIsxet2rO1dzPHqsIblWQwKS7akf2fkeTeT3TTXffdyj9UgfjqED8k/iaW2aaoB2r/Vg+feaqa4Z6ie8tB5Vi3eutU39mlZrtVrCdWaXWqL1HFotGZj9elmtTnAdQfp/3RgLYY08rstaTGm1QOgThR79K7pqe2BCOK0HaIqtXoNeTfuLphfGHs5l2dts0H4kber3n+MeP9L2eLSd9/imXtsCr8GRQq/130OiR59recm9L8odEA7ziXO2ri8WYU37I9ZZ6R2038Vi4Cs9QNv3BbPR2ZNZPirSRWZfT7bdF8j//cQl2FVuzum6dzlDMz3+wI70/WBt7yHE1g2tIs/Svd1AF9SMNzyUb51y81tSVunDskovsvtlVUfBDQCHuWHh0L2jv5CX6BER/VtQmy30YI7MHyryeyR/Q2/lG98XDxT6gUJv1+eBm7S6kwDZbfc1NzKJP35j3SR2fNzDLVNqPCvGWfYozxZ5NtqWV/8B9wtZS8UtAAA=","debug_symbols":"tZjdTiM5EIXfJde5sMtlu8yrjBAKEEaRooAysNIK8e5bFdfpTpDcmu3R3OR8Tegv/inbnXxunvePHz8fDqeX11+bux+fm8fz4Xg8/Hw4vj7t3g+vJ/3r5ybYC+lr2m4obu6yBvVIPbhH7lF61B7So10iqUU0Yg/qkXqoJepHJNVE+9/iWT3VFItm68nqinofR0/yTJ7smT2LZ/UUT/VR3G5y8Iye5Kk+0s8rep30uiRP9syexbN6imfrWYNn9HRfNR9psmf2LJ7VUzxbTwme0ZM83SfuE/eJ+8R8QVM8W88WPKMneSZP9syexdN9zX3NfDqPMQRABBAgARiQAQVQAQKAOcIcYY4wR5gjzBHmCHOEOcIczaw1Fi9lXgwigAAJYOZqkAEFUAECaA5W+h0igAAJYGYxyA5WvKkZ6EdwMKgAATQHq+AO+hEcDVTIZJABBVABAmgOJQDMY+Njtd8hARiQAQVQAWZmg+Zga6BDBBAgARiQASa02bEl0KE52CLoEAEESAAGZEABwCww22pgm2VbDh0igAAJwIAMwPA2DG/D8DYfXrJS52pgb4lBc7DC7hAB1AuALoV9AQZkQAFUgACaw6WwLxABMBPMBDPBTDATzFbPl8ZbPbP9xaq3A3ubrXo7FEAF2HEQDJqDbeMd7GiJBgRIAJgZZoaZYWYMJmMwMwYzYzBtS++QADBf1oV8fW03OPse3s/7vR19V4ehHpFvu/P+9L65O30cj9vNP7vjx+Wffr3tTpd83531Xe3Q/vSsqcKXw3Fv9LWd7w7jW7lS9bu5cp4E+dYQFwySGAZhmgyl3RhobJBcyQ2SpY4Mi70oUxuqlFEveGzQkyC5Qff5NBl0D/ptha5rKOhqKL8ryliRc8NcFiGeFaHeKOpYUUt0Q60yCyqtGsvWRmPZlgbCNjcfyxqGjYgLrahZ0IpaQh7VRFwozJoEU1qZhoUZaaknqZapKxzaULLYlTp3hcJQsVBa8wLJMrchcVozqRLiaFLD4jLPkyGPN4r652ts0fGbiyy2P19lFP7mMrsezzJcZrRUnRzQiMhUh62gtLD3hoQCl5BluHsvFGcVO6v7WEgb1jflxR1D5i0jU1lxBujDphsozIs9Ub5txdLW2aZ9Sze+uT5J5NYhY0eqKC1Oc2XRt0ldKE59ZEIj9FkpjRRpYSQy40jPLGsEZWpCGbdgsRMpYqVTuprN/6OojJGkmodDmfivKvRbBfZNPclolaI2TId+byirFC1NG2fjoWJpcYRpKPQbbltj0K9386FOqwwynaUUVrWB6WrDW9WGzFMvco2rDG2aixLTGkOaZzPlVb1IZToEk6zphT5TTY8kvOL+Np3kra6px0bYYRqv+nxB+2826jXt/3b/vV7tng7nm18lv8x0Puwej3u/fPk4PV29+/7vG97Br5pv59en/fPHeW+m+adNfflBhbYk6d5+ZdLLnLcl2EW093TDISn3X9aU/wA=","names":["update_token_uri"],"brillig_names":["update_token_uri"]},{"name":"update_username","hash":"6209026253320410679","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"old_username_hash","type":{"kind":"field"},"visibility":"private"},{"name":"new_username_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"12404158037908504363":{"error_kind":"string","string":"Not your username"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"16481276443224907681":{"error_kind":"string","string":"New username taken"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","names":["update_username"],"brillig_names":["update_username"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"AztlanProfileRegistry::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::create_profile_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::create_profile_parameters","fields":[{"name":"username_hash","type":{"kind":"field"}},{"name":"token_uri_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_address_by_username_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_address_by_username_parameters","fields":[{"name":"username_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_admin_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_next_profile_id_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_next_profile_id_parameters","fields":[]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_profile_id_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_profile_id_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_quest_points_contract_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_quest_points_contract_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_social_verifier_contract_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_social_verifier_contract_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_token_uri_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_token_uri_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_total_profiles_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_total_profiles_parameters","fields":[]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_username_change_cooldown_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_username_change_cooldown_parameters","fields":[]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::get_username_change_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::get_username_change_count_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"AztlanProfileRegistry::has_profile_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::has_profile_parameters","fields":[{"name":"user","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"AztlanProfileRegistry::is_username_available_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::is_username_available_parameters","fields":[{"name":"username_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"boolean"}}]},{"kind":"struct","path":"AztlanProfileRegistry::set_contracts_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::set_contracts_parameters","fields":[{"name":"social_verifier","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"quest_points","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::set_username_change_cooldown_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::set_username_change_cooldown_parameters","fields":[{"name":"new_cooldown","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::transfer_admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::transfer_admin_parameters","fields":[{"name":"new_admin","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::update_token_uri_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::update_token_uri_parameters","fields":[{"name":"new_uri_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"AztlanProfileRegistry::update_username_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"AztlanProfileRegistry::update_username_parameters","fields":[{"name":"old_username_hash","type":{"kind":"field"}},{"name":"new_username_hash","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"AztlanProfileRegistry"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"username_to_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"profile_id_of","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"token_uri","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"has_profile","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"profile_created_at","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"username_last_changed","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"username_change_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"social_verifier_contract","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"quest_points_contract","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}},{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}},{"name":"total_profiles","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}]}},{"name":"next_profile_id","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000c"}}]}},{"name":"username_change_cooldown","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000d"}}]}}]}}]}]}},"file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"25":{"source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n","path":"std/meta/expr.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n// CONTRACT 1: PUBLIC PROFILE REGISTRY - COMPLETE VERSION\n#[aztec]\npub contract AztlanProfileRegistry {\n    use dep::aztec::macros::{functions::{public}, storage::storage};\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    #[storage]\n    struct Storage<Context> {\n        // Core mappings\n        username_to_address: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        profile_id_of: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // NFT data\n        token_uri: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Metadata\n        has_profile: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        profile_created_at: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Username change tracking\n        username_last_changed: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        username_change_count: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        \n        // Contract references (untuk integrasi)\n        social_verifier_contract: PublicMutable<AztecAddress, Context>,\n        quest_points_contract: PublicMutable<AztecAddress, Context>,\n        \n        // Admin\n        admin: PublicMutable<AztecAddress, Context>,\n        \n        // Stats\n        total_profiles: PublicMutable<Field, Context>,\n        next_profile_id: PublicMutable<Field, Context>,\n        \n        // Config\n        username_change_cooldown: PublicMutable<Field, Context>,\n    }\n\n    #[public]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n        storage.total_profiles.write(0);\n        storage.next_profile_id.write(1);\n        storage.username_change_cooldown.write(30); // 30 blocks cooldown\n    }\n\n    #[public]\n    fn set_contracts(\n        social_verifier: AztecAddress,\n        quest_points: AztecAddress\n    ) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        \n        storage.social_verifier_contract.write(social_verifier);\n        storage.quest_points_contract.write(quest_points);\n    }\n\n    #[public]\n    fn create_profile(\n        username_hash: Field,\n        token_uri_hash: Field\n    ) {\n        let caller = context.msg_sender();\n        \n        // Validations\n        assert(!storage.has_profile.at(caller).read(), \"Profile exists\");\n        assert(\n            storage.username_to_address.at(username_hash).read() == AztecAddress::zero(),\n            \"Username taken\"\n        );\n        \n        // Get profile ID\n        let profile_id = storage.next_profile_id.read();\n        \n        // Store profile data\n        storage.username_to_address.at(username_hash).write(caller);\n        storage.profile_id_of.at(caller).write(profile_id);\n        storage.token_uri.at(caller).write(token_uri_hash);\n        storage.has_profile.at(caller).write(true);\n        storage.profile_created_at.at(caller).write(0); // Block number would be better\n        storage.username_last_changed.at(caller).write(0);\n        storage.username_change_count.at(caller).write(0);\n        \n        // Update counters\n        storage.total_profiles.write(storage.total_profiles.read() + 1);\n        storage.next_profile_id.write(profile_id + 1);\n    }\n\n    #[public]\n    fn update_username(\n        old_username_hash: Field,\n        new_username_hash: Field\n    ) {\n        let caller = context.msg_sender();\n        \n        // Verify caller owns the old username\n        assert(\n            storage.username_to_address.at(old_username_hash).read() == caller,\n            \"Not your username\"\n        );\n        \n        // Check new username available\n        assert(\n            storage.username_to_address.at(new_username_hash).read() == AztecAddress::zero(),\n            \"New username taken\"\n        );\n        \n        // Check cooldown (simplified - in production use block numbers)\n        let last_changed = storage.username_last_changed.at(caller).read();\n        let cooldown = storage.username_change_cooldown.read();\n        // In production: assert(current_block - last_changed >= cooldown)\n        \n        // Update mappings\n        storage.username_to_address.at(old_username_hash).write(AztecAddress::zero());\n        storage.username_to_address.at(new_username_hash).write(caller);\n        \n        // Update metadata\n        storage.username_last_changed.at(caller).write(1); // Should be block number\n        let change_count = storage.username_change_count.at(caller).read();\n        storage.username_change_count.at(caller).write(change_count + 1);\n    }\n\n    #[public]\n    fn update_token_uri(new_uri_hash: Field) {\n        let caller = context.msg_sender();\n        assert(storage.has_profile.at(caller).read(), \"No profile\");\n        \n        storage.token_uri.at(caller).write(new_uri_hash);\n    }\n\n    // ADMIN FUNCTIONS\n    \n    #[public]\n    fn set_username_change_cooldown(new_cooldown: Field) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        \n        storage.username_change_cooldown.write(new_cooldown);\n    }\n\n    #[public]\n    fn transfer_admin(new_admin: AztecAddress) {\n        let caller = context.msg_sender();\n        assert(caller == storage.admin.read(), \"Only admin\");\n        \n        storage.admin.write(new_admin);\n    }\n\n    // VIEW FUNCTIONS\n    \n    #[public]\n    fn get_profile_id(user: AztecAddress) -> Field {\n        storage.profile_id_of.at(user).read()\n    }\n\n    #[public]\n    fn get_address_by_username(username_hash: Field) -> AztecAddress {\n        storage.username_to_address.at(username_hash).read()\n    }\n\n    #[public]\n    fn get_token_uri(user: AztecAddress) -> Field {\n        storage.token_uri.at(user).read()\n    }\n\n    #[public]\n    fn has_profile(user: AztecAddress) -> bool {\n        storage.has_profile.at(user).read()\n    }\n\n    #[public]\n    fn is_username_available(username_hash: Field) -> bool {\n        storage.username_to_address.at(username_hash).read() == AztecAddress::zero()\n    }\n\n    #[public]\n    fn get_username_change_count(user: AztecAddress) -> Field {\n        storage.username_change_count.at(user).read()\n    }\n\n    #[public]\n    fn get_social_verifier_contract() -> AztecAddress {\n        storage.social_verifier_contract.read()\n    }\n\n    #[public]\n    fn get_quest_points_contract() -> AztecAddress {\n        storage.quest_points_contract.read()\n    }\n\n    #[public]\n    fn get_total_profiles() -> Field {\n        storage.total_profiles.read()\n    }\n\n    #[public]\n    fn get_next_profile_id() -> Field {\n        storage.next_profile_id.read()\n    }\n\n    #[public]\n    fn get_admin() -> AztecAddress {\n        storage.admin.read()\n    }\n\n    #[public]\n    fn get_username_change_cooldown() -> Field {\n        storage.username_change_cooldown.read()\n    }\n}\n","path":"/root/x/aztlan/contracts/aztlan_profile/src/main.nr"},"69":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, calldata);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"71":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"97":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"104":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"146":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"163":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"172":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"270":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"288":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"325":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"343":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"344":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"363":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/root/nargo/github.com/AztecProtocol/aztec-packages/alpha-testnet/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}